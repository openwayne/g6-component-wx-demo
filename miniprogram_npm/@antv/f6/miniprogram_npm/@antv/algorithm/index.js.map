{"version":3,"sources":["index.js","adjacent-matrix.js","bfs.js","structs/queue.js","structs/linked-list.js","util.js","connected-component.js","degree.js","detect-cycle.js","dfs.js","dijkstra.js","find-path.js","floydWarshall.js","label-propagation.js","louvain.js","mts.js","structs/union-find.js","structs/binary-heap.js","pageRank.js","gaddi.js","gSpan/gSpan.js","gSpan/struct.js","structs/stack.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA,AENA;AJaA,ACHA,AFMA,AIZA,ADGA,AENA;AJaA,ACHA,AFMA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ANkBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ANkBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ANkBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,APqBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,APqBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,APqBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ARwBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ARwBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ARwBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,AT2BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,AT2BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,AT2BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AV8BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AV8BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AV8BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,AT2BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,AT2BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,AT2BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AXiCA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AXiCA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AXiCA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AXiCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AXiCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AXiCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AENA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AENA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AENA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AOrBA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AOrBA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AOrBA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ADGA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ADGA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ADGA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AavCA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,ADGA,AmBzDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;AHUA,AIZA,AENA,ACHA,ACHA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,ANkBA,AXiCA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,ACHA,AS3BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA,AjBmDA;ACFA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AGTA,ADGA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA,AkBtDA;AhBiDA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA;AELA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA;AELA,AENA,AENA,AU9BA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AENA,AbuCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AELA,AENA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,ACHA,AXiCA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ACHA,AFMA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ADGA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ADGA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ADGA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ADGA,AnByDA,AavCA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ANkBA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ANkBA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ANkBA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ANkBA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ANkBA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ANkBA,ACHA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA,AV8BA;AIXA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA,ALeA;ANmBA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;AXkCA,AYpCA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getAdjMatrix\", {\n  enumerable: true,\n  get: function get() {\n    return _adjacentMatrix.default;\n  }\n});\nObject.defineProperty(exports, \"breadthFirstSearch\", {\n  enumerable: true,\n  get: function get() {\n    return _bfs.default;\n  }\n});\nObject.defineProperty(exports, \"connectedComponent\", {\n  enumerable: true,\n  get: function get() {\n    return _connectedComponent.default;\n  }\n});\nObject.defineProperty(exports, \"getDegree\", {\n  enumerable: true,\n  get: function get() {\n    return _degree.default;\n  }\n});\nObject.defineProperty(exports, \"getInDegree\", {\n  enumerable: true,\n  get: function get() {\n    return _degree.getInDegree;\n  }\n});\nObject.defineProperty(exports, \"getOutDegree\", {\n  enumerable: true,\n  get: function get() {\n    return _degree.getOutDegree;\n  }\n});\nObject.defineProperty(exports, \"detectCycle\", {\n  enumerable: true,\n  get: function get() {\n    return _detectCycle.default;\n  }\n});\nObject.defineProperty(exports, \"detectAllCycles\", {\n  enumerable: true,\n  get: function get() {\n    return _detectCycle.detectAllCycles;\n  }\n});\nObject.defineProperty(exports, \"detectAllDirectedCycle\", {\n  enumerable: true,\n  get: function get() {\n    return _detectCycle.detectAllDirectedCycle;\n  }\n});\nObject.defineProperty(exports, \"detectAllUndirectedCycle\", {\n  enumerable: true,\n  get: function get() {\n    return _detectCycle.detectAllUndirectedCycle;\n  }\n});\nObject.defineProperty(exports, \"depthFirstSearch\", {\n  enumerable: true,\n  get: function get() {\n    return _dfs.default;\n  }\n});\nObject.defineProperty(exports, \"dijkstra\", {\n  enumerable: true,\n  get: function get() {\n    return _dijkstra.default;\n  }\n});\nObject.defineProperty(exports, \"findAllPath\", {\n  enumerable: true,\n  get: function get() {\n    return _findPath.findAllPath;\n  }\n});\nObject.defineProperty(exports, \"findShortestPath\", {\n  enumerable: true,\n  get: function get() {\n    return _findPath.findShortestPath;\n  }\n});\nObject.defineProperty(exports, \"floydWarshall\", {\n  enumerable: true,\n  get: function get() {\n    return _floydWarshall.default;\n  }\n});\nObject.defineProperty(exports, \"labelPropagation\", {\n  enumerable: true,\n  get: function get() {\n    return _labelPropagation.default;\n  }\n});\nObject.defineProperty(exports, \"louvain\", {\n  enumerable: true,\n  get: function get() {\n    return _louvain.default;\n  }\n});\nObject.defineProperty(exports, \"minimumSpanningTree\", {\n  enumerable: true,\n  get: function get() {\n    return _mts.default;\n  }\n});\nObject.defineProperty(exports, \"pageRank\", {\n  enumerable: true,\n  get: function get() {\n    return _pageRank.default;\n  }\n});\nObject.defineProperty(exports, \"GADDI\", {\n  enumerable: true,\n  get: function get() {\n    return _gaddi.default;\n  }\n});\nObject.defineProperty(exports, \"Stack\", {\n  enumerable: true,\n  get: function get() {\n    return _stack.default;\n  }\n});\nObject.defineProperty(exports, \"getNeighbors\", {\n  enumerable: true,\n  get: function get() {\n    return _util.getNeighbors;\n  }\n});\nexports.default = exports.detectDirectedCycle = void 0;\n\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\n\nvar _bfs = _interopRequireDefault(require(\"./bfs\"));\n\nvar _connectedComponent = _interopRequireDefault(require(\"./connected-component\"));\n\nvar _degree = _interopRequireWildcard(require(\"./degree\"));\n\nvar _detectCycle = _interopRequireWildcard(require(\"./detect-cycle\"));\n\nvar _dfs = _interopRequireDefault(require(\"./dfs\"));\n\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\n\nvar _findPath = require(\"./find-path\");\n\nvar _floydWarshall = _interopRequireDefault(require(\"./floydWarshall\"));\n\nvar _labelPropagation = _interopRequireDefault(require(\"./label-propagation\"));\n\nvar _louvain = _interopRequireDefault(require(\"./louvain\"));\n\nvar _mts = _interopRequireDefault(require(\"./mts\"));\n\nvar _pageRank = _interopRequireDefault(require(\"./pageRank\"));\n\nvar _gaddi = _interopRequireDefault(require(\"./gaddi\"));\n\nvar _stack = _interopRequireDefault(require(\"./structs/stack\"));\n\nvar _util = require(\"./util\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar detectDirectedCycle = _detectCycle.default;\nexports.detectDirectedCycle = detectDirectedCycle;\nvar _default = {\n  getAdjMatrix: _adjacentMatrix.default,\n  breadthFirstSearch: _bfs.default,\n  connectedComponent: _connectedComponent.default,\n  getDegree: _degree.default,\n  getInDegree: _degree.getInDegree,\n  getOutDegree: _degree.getOutDegree,\n  detectCycle: _detectCycle.default,\n  detectDirectedCycle: detectDirectedCycle,\n  detectAllCycles: _detectCycle.detectAllCycles,\n  detectAllDirectedCycle: _detectCycle.detectAllDirectedCycle,\n  detectAllUndirectedCycle: _detectCycle.detectAllUndirectedCycle,\n  depthFirstSearch: _dfs.default,\n  dijkstra: _dijkstra.default,\n  findAllPath: _findPath.findAllPath,\n  findShortestPath: _findPath.findShortestPath,\n  floydWarshall: _floydWarshall.default,\n  labelPropagation: _labelPropagation.default,\n  louvain: _louvain.default,\n  minimumSpanningTree: _mts.default,\n  pageRank: _pageRank.default,\n  getNeighbors: _util.getNeighbors,\n  Stack: _stack.default,\n  GADDI: _gaddi.default\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar adjMatrix = function adjMatrix(graphData, directed) {\n  var nodes = graphData.nodes,\n      edges = graphData.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error(\"invalid nodes data!\");\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (edge) {\n      var source = edge.source,\n          target = edge.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0) return;\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n\nvar _default = adjMatrix;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _queue = _interopRequireDefault(require(\"./structs/queue\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *\n * @param callbacks\n * allowTraversal: 确定 BFS 是否从顶点沿着边遍历到其邻居，默认情况下，同一个节点只能遍历一次\n * enterNode: 当 BFS 访问某个节点时调用\n * leaveNode: 当 BFS 访问访问结束某个节点时调用\n */\nfunction initCallbacks(callbacks) {\n  if (callbacks === void 0) {\n    callbacks = {};\n  }\n\n  var initiatedCallback = callbacks;\n\n  var stubCallback = function stubCallback() {};\n\n  var allowTraversalCallback = function () {\n    var seen = {};\n    return function (_a) {\n      var next = _a.next;\n      var id = next;\n\n      if (!seen[id]) {\n        seen[id] = true;\n        return true;\n      }\n\n      return false;\n    };\n  }();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n  return initiatedCallback;\n}\n/**\n * 广度优先遍历图\n * @param graph Graph 图实例\n * @param startNode 开始遍历的节点\n * @param originalCallbacks 回调\n */\n\n\nvar breadthFirstSearch = function breadthFirstSearch(graphData, startNodeId, originalCallbacks) {\n  var callbacks = initCallbacks(originalCallbacks);\n  var nodeQueue = new _queue.default();\n  var _a = graphData.edges,\n      edges = _a === void 0 ? [] : _a; // 初始化队列元素\n\n  nodeQueue.enqueue(startNodeId);\n  var previousNode = '';\n\n  var _loop_1 = function _loop_1() {\n    var currentNode = nodeQueue.dequeue();\n    callbacks.enter({\n      current: currentNode,\n      previous: previousNode\n    }); // 将所有邻居添加到队列中以便遍历\n\n    (0, _util.getNeighbors)(currentNode, edges, 'target').forEach(function (nextNode) {\n      if (callbacks.allowTraversal({\n        previous: previousNode,\n        current: currentNode,\n        next: nextNode\n      })) {\n        nodeQueue.enqueue(nextNode);\n      }\n    });\n    callbacks.leave({\n      current: currentNode,\n      previous: previousNode\n    }); // 下一次循环之前存储当前顶点\n\n    previousNode = currentNode;\n  }; // 遍历队列中的所有顶点\n\n\n  while (!nodeQueue.isEmpty()) {\n    _loop_1();\n  }\n};\n\nvar _default = breadthFirstSearch;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _linkedList = _interopRequireDefault(require(\"./linked-list\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Queue =\n/** @class */\nfunction () {\n  function Queue() {\n    this.linkedList = new _linkedList.default();\n  }\n  /**\n   * 队列是否为空\n   */\n\n\n  Queue.prototype.isEmpty = function () {\n    return !this.linkedList.head;\n  };\n  /**\n   * 读取队列头部的元素， 不删除队列中的元素\n   */\n\n\n  Queue.prototype.peek = function () {\n    if (!this.linkedList.head) {\n      return null;\n    }\n\n    return this.linkedList.head.value;\n  };\n  /**\n   * 在队列的尾部新增一个元素\n   * @param value\n   */\n\n\n  Queue.prototype.enqueue = function (value) {\n    this.linkedList.append(value);\n  };\n  /**\n   * 删除队列中的头部元素，如果队列为空，则返回 null\n   */\n\n\n  Queue.prototype.dequeue = function () {\n    var removeHead = this.linkedList.deleteHead();\n    return removeHead ? removeHead.value : null;\n  };\n\n  Queue.prototype.toString = function (callback) {\n    return this.linkedList.toString(callback);\n  };\n\n  return Queue;\n}();\n\nvar _default = Queue;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.LinkedListNode = void 0;\n\nvar defaultComparator = function defaultComparator(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * 链表中单个元素节点\n */\n\n\nvar LinkedListNode =\n/** @class */\nfunction () {\n  function LinkedListNode(value, next) {\n    if (next === void 0) {\n      next = null;\n    }\n\n    this.value = value;\n    this.next = next;\n  }\n\n  LinkedListNode.prototype.toString = function (callback) {\n    return callback ? callback(this.value) : \"\" + this.value;\n  };\n\n  return LinkedListNode;\n}();\n\nexports.LinkedListNode = LinkedListNode;\n\nvar LinkedList =\n/** @class */\nfunction () {\n  function LinkedList(comparator) {\n    if (comparator === void 0) {\n      comparator = defaultComparator;\n    }\n\n    this.head = null;\n    this.tail = null;\n    this.compare = comparator;\n  }\n  /**\n   * 将指定元素添加到链表头部\n   * @param value\n   */\n\n\n  LinkedList.prototype.prepend = function (value) {\n    // 在头部添加一个节点\n    var newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  };\n  /**\n   * 将指定元素添加到链表中\n   * @param value\n   */\n\n\n  LinkedList.prototype.append = function (value) {\n    var newNode = new LinkedListNode(value); // 如果不存在头节点，则将创建的新节点作为头节点\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    } // 将新节点附加到链表末尾\n\n\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };\n  /**\n   * 删除指定元素\n   * @param value 要删除的元素\n   */\n\n\n  LinkedList.prototype.delete = function (value) {\n    if (!this.head) {\n      return null;\n    }\n\n    var deleteNode = null; // 如果删除的是头部元素，则将next作为头元素\n\n    while (this.head && this.compare(this.head.value, value)) {\n      deleteNode = this.head;\n      this.head = this.head.next;\n    }\n\n    var currentNode = this.head;\n\n    if (currentNode !== null) {\n      // 如果删除了节点以后，将next节点前移\n      while (currentNode.next) {\n        if (this.compare(currentNode.next.value, value)) {\n          deleteNode = currentNode.next;\n          currentNode.next = currentNode.next.next;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n    } // 检查尾部节点是否被删除\n\n\n    if (this.compare(this.tail.value, value)) {\n      this.tail = currentNode;\n    }\n\n    return deleteNode;\n  };\n  /**\n   * 查找指定的元素\n   * @param param0\n   */\n\n\n  LinkedList.prototype.find = function (_a) {\n    var _b = _a.value,\n        value = _b === void 0 ? undefined : _b,\n        _c = _a.callback,\n        callback = _c === void 0 ? undefined : _c;\n\n    if (!this.head) {\n      return null;\n    }\n\n    var currentNode = this.head;\n\n    while (currentNode) {\n      // 如果指定了 callback，则按指定的 callback 查找\n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      } // 如果指定了 value，则按 value 查找\n\n\n      if (value !== undefined && this.compare(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  };\n  /**\n   * 删除尾部节点\n   */\n\n\n  LinkedList.prototype.deleteTail = function () {\n    var deletedTail = this.tail;\n\n    if (this.head === this.tail) {\n      // 链表中只有一个元素\n      this.head = null;\n      this.tail = null;\n      return deletedTail;\n    }\n\n    var currentNode = this.head;\n\n    while (currentNode.next) {\n      if (!currentNode.next.next) {\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n\n    this.tail = currentNode;\n    return deletedTail;\n  };\n  /**\n   * 删除头部节点\n   */\n\n\n  LinkedList.prototype.deleteHead = function () {\n    if (!this.head) {\n      return null;\n    }\n\n    var deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  };\n  /**\n   * 将一组元素转成链表中的节点\n   * @param values 链表中的元素\n   */\n\n\n  LinkedList.prototype.fromArray = function (values) {\n    var _this = this;\n\n    values.forEach(function (value) {\n      return _this.append(value);\n    });\n    return this;\n  };\n  /**\n   * 将链表中的节点转成数组元素\n   */\n\n\n  LinkedList.prototype.toArray = function () {\n    var nodes = [];\n    var currentNode = this.head;\n\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  };\n  /**\n   * 反转链表中的元素节点\n   */\n\n\n  LinkedList.prototype.reverse = function () {\n    var currentNode = this.head;\n    var prevNode = null;\n    var nextNode = null;\n\n    while (currentNode) {\n      // 存储下一个元素节点\n      nextNode = currentNode.next; // 更改当前节点的下一个节点，以便将它连接到上一个节点上\n\n      currentNode.next = prevNode; // 将 prevNode 和 currentNode 向前移动一步\n\n      prevNode = currentNode;\n      currentNode = nextNode;\n    }\n\n    this.tail = this.head;\n    this.head = prevNode;\n  };\n\n  LinkedList.prototype.toString = function (callback) {\n    if (callback === void 0) {\n      callback = undefined;\n    }\n\n    return this.toArray().map(function (node) {\n      return node.toString(callback);\n    }).toString();\n  };\n\n  return LinkedList;\n}();\n\nvar _default = LinkedList;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniqueId = exports.getEdgesByNodeId = exports.getOutEdgesNodeId = exports.getNeighbors = void 0;\n\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\nvar getNeighbors = function getNeighbors(nodeId, edges, type) {\n  if (edges === void 0) {\n    edges = [];\n  }\n\n  var currentEdges = edges.filter(function (edge) {\n    return edge.source === nodeId || edge.target === nodeId;\n  });\n\n  if (type === 'target') {\n    // 当前节点为 source，它所指向的目标节点\n    var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n      return edge.source === nodeId;\n    };\n\n    return currentEdges.filter(neighhborsConverter_1).map(function (edge) {\n      return edge.target;\n    });\n  }\n\n  if (type === 'source') {\n    // 当前节点为 target，它所指向的源节点\n    var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n      return edge.target === nodeId;\n    };\n\n    return currentEdges.filter(neighhborsConverter_2).map(function (edge) {\n      return edge.source;\n    });\n  } // 若未指定 type ，则返回所有邻居\n\n\n  var neighhborsConverter = function neighhborsConverter(edge) {\n    return edge.source === nodeId ? edge.target : edge.source;\n  };\n\n  return currentEdges.map(neighhborsConverter);\n};\n/**\n * 获取指定节点的出边\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n */\n\n\nexports.getNeighbors = getNeighbors;\n\nvar getOutEdgesNodeId = function getOutEdgesNodeId(nodeId, edges) {\n  return edges.filter(function (edge) {\n    return edge.source === nodeId;\n  });\n};\n/**\n * 获取指定节点的边，包括出边和入边\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n */\n\n\nexports.getOutEdgesNodeId = getOutEdgesNodeId;\n\nvar getEdgesByNodeId = function getEdgesByNodeId(nodeId, edges) {\n  return edges.filter(function (edge) {\n    return edge.source === nodeId || edge.target === nodeId;\n  });\n};\n/**\n * 生成唯一的 ID，规则是序号 + 时间戳\n * @param index 序号\n */\n\n\nexports.getEdgesByNodeId = getEdgesByNodeId;\n\nvar uniqueId = function uniqueId(index) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  var random1 = (\"\" + Math.random()).split('.')[1].substr(0, 5);\n  var random2 = (\"\" + Math.random()).split('.')[1].substr(0, 5);\n  return index + \"-\" + random1 + random2;\n};\n\nexports.uniqueId = uniqueId;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getConnectedComponents;\nexports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;\n\nvar _util = require(\"./util\");\n\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nvar detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = (0, _util.getNeighbors)(node.id, edges);\n\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\n\nexports.detectConnectedComponents = detectConnectedComponents;\n\nvar detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true; // 考虑每个邻接点\n\n    var neighbors = (0, _util.getNeighbors)(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        } // tree edge\n\n\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n};\n\nexports.detectStrongConnectComponents = detectStrongConnectComponents;\n\nfunction getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOutDegree = exports.getInDegree = exports.default = void 0;\n\nvar degree = function degree(graphData) {\n  var degrees = {};\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  nodes.forEach(function (node) {\n    degrees[node.id] = {\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0\n    };\n  });\n  edges.forEach(function (edge) {\n    degrees[edge.source].degree++;\n    degrees[edge.source].outDegree++;\n    degrees[edge.target].degree++;\n    degrees[edge.target].inDegree++;\n  });\n  return degrees;\n};\n\nvar _default = degree;\n/**\n * 获取指定节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\nexports.default = _default;\n\nvar getInDegree = function getInDegree(graphData, nodeId) {\n  var nodeDegree = degree(graphData);\n\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].inDegree;\n  }\n\n  return 0;\n};\n/**\n * 获取指定节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\n\nexports.getInDegree = getInDegree;\n\nvar getOutDegree = function getOutDegree(graphData, nodeId) {\n  var nodeDegree = degree(graphData);\n\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].outDegree;\n  }\n\n  return 0;\n};\n\nexports.getOutDegree = getOutDegree;","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.detectAllCycles = exports.detectAllDirectedCycle = exports.detectAllUndirectedCycle = void 0;\n\nvar _dfs = _interopRequireDefault(require(\"./dfs\"));\n\nvar _connectedComponent = _interopRequireWildcard(require(\"./connected-component\"));\n\nvar _util = require(\"./util\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar detectDirectedCycle = function detectDirectedCycle(graphData) {\n  var cycle = null;\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a;\n  var dfsParentMap = {}; // 所有没有被访问的节点集合\n\n  var unvisitedSet = {}; // 正在被访问的节点集合\n\n  var visitingSet = {}; // 所有已经被访问过的节点集合\n\n  var visitedSet = {}; // 初始化 unvisitedSet\n\n  nodes.forEach(function (node) {\n    unvisitedSet[node.id] = node;\n  });\n  var callbacks = {\n    enter: function enter(_a) {\n      var currentNode = _a.current,\n          previousNode = _a.previous;\n\n      if (visitingSet[currentNode]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n        var currentCycleNode = currentNode;\n        var previousCycleNode = previousNode;\n\n        while (previousCycleNode !== currentNode) {\n          cycle[currentCycleNode] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode];\n        }\n\n        cycle[currentCycleNode] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode] = currentNode;\n        delete unvisitedSet[currentNode]; // 更新 DSF parents 列表\n\n        dfsParentMap[currentNode] = previousNode;\n      }\n    },\n    leave: function leave(_a) {\n      var currentNode = _a.current; // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n\n      visitedSet[currentNode] = currentNode;\n      delete visitingSet[currentNode];\n    },\n    allowTraversal: function allowTraversal(_a) {\n      var nextNode = _a.next; // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n\n      if (cycle) {\n        return false;\n      } // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n\n\n      return !visitedSet[nextNode];\n    }\n  }; // 开始遍历节点\n\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n    (0, _dfs.default)(graphData, firsetUnVisitedKey, callbacks);\n  }\n\n  return cycle;\n};\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\n\n\nvar detectAllUndirectedCycle = function detectAllUndirectedCycle(graphData, nodeIds, include) {\n  var _a, _b;\n\n  if (include === void 0) {\n    include = true;\n  }\n\n  var allCycles = [];\n  var components = (0, _connectedComponent.default)(graphData, false); // loop through all connected components\n\n  for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n    var component = components_1[_i];\n    if (!component.length) continue;\n    var root = component[0];\n    var rootId = root.id;\n    var stack = [root];\n    var parent_1 = (_a = {}, _a[rootId] = root, _a);\n    var used = (_b = {}, _b[rootId] = new Set(), _b); // walk a spanning tree to find cycles\n\n    while (stack.length > 0) {\n      var curNode = stack.pop();\n      var curNodeId = curNode.id;\n      var neighbors = (0, _util.getNeighbors)(curNodeId, graphData.edges);\n\n      var _loop_1 = function _loop_1(i) {\n        var _c;\n\n        var neighborId = neighbors[i];\n        var neighbor = graphData.nodes.find(function (node) {\n          return node.id === neighborId;\n        }); // const neighborId = neighbor.get('id');\n\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent_1[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          var cycleValid = true;\n          var cyclePath = [neighbor, curNode];\n          var p = parent_1[curNodeId];\n\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent_1[p.id]) break;else p = parent_1[p.id];\n          }\n\n          cyclePath.push(p);\n\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.id) > -1;\n            }) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.id) > -1;\n            }) > -1) {\n              cycleValid = false;\n            }\n          } // 把 node list 形式转换为 cycle 的格式\n\n\n          if (cycleValid) {\n            var cycle = {};\n\n            for (var index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\n            }\n\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\n            }\n\n            allCycles.push(cycle);\n          }\n\n          used[neighborId].add(curNode);\n        }\n      };\n\n      for (var i = 0; i < neighbors.length; i += 1) {\n        _loop_1(i);\n      }\n    }\n  }\n\n  return allCycles;\n};\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的 simple cycles\n */\n\n\nexports.detectAllUndirectedCycle = detectAllUndirectedCycle;\n\nvar detectAllDirectedCycle = function detectAllDirectedCycle(graphData, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n\n  var path = []; // stack of nodes in current path\n\n  var blocked = new Set();\n  var B = []; // remember portions of the graph that yield no elementary circuit\n\n  var allCycles = [];\n  var idx2Node = {};\n  var node2Idx = {}; // 辅助函数： unblock all blocked nodes\n\n  var unblock = function unblock(thisNode) {\n    var stack = [thisNode];\n\n    while (stack.length > 0) {\n      var node = stack.pop();\n\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.id].forEach(function (n) {\n          stack.push(n);\n        });\n        B[node.id].clear();\n      }\n    }\n  };\n\n  var circuit = function circuit(node, start, adjList) {\n    var closed = false; // whether a path is closed\n\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n    var neighbors = adjList[node.id];\n\n    for (var i = 0; i < neighbors.length; i += 1) {\n      var neighbor = idx2Node[neighbors[i]];\n\n      if (neighbor === start) {\n        var cycle = {};\n\n        for (var index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].id] = path[index];\n        }\n\n        if (path.length) {\n          cycle[path[path.length - 1].id] = path[0];\n        }\n\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n\n    if (closed) {\n      unblock(node);\n    } else {\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = idx2Node[neighbors[i]];\n\n        if (!B[neighbor.id].has(node)) {\n          B[neighbor.id].add(node);\n        }\n      }\n    }\n\n    path.pop();\n    return closed;\n  };\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a; // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n\n  for (var i = 0; i < nodes.length; i += 1) {\n    var node = nodes[i];\n    var nodeId = node.id;\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  } // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n\n\n  if (nodeIds && include) {\n    var _loop_2 = function _loop_2(i) {\n      var nodeId = nodeIds[i];\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\n    };\n\n    for (var i = 0; i < nodeIds.length; i++) {\n      _loop_2(i);\n    }\n  } // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n\n\n  var getMinComponentAdj = function getMinComponentAdj(components) {\n    var _a;\n\n    var minCompIdx;\n    var minIdx = Infinity; // Find least component and the lowest node\n\n    for (var i = 0; i < components.length; i += 1) {\n      var comp = components[i];\n\n      for (var j = 0; j < comp.length; j++) {\n        var nodeIdx_1 = node2Idx[comp[j].id];\n\n        if (nodeIdx_1 < minIdx) {\n          minIdx = nodeIdx_1;\n          minCompIdx = i;\n        }\n      }\n    }\n\n    var component = components[minCompIdx];\n    var adjList = [];\n\n    for (var i = 0; i < component.length; i += 1) {\n      var node = component[i];\n      adjList[node.id] = [];\n\n      for (var _i = 0, _b = (0, _util.getNeighbors)(node.id, graphData.edges, 'target').filter(function (n) {\n        return component.map(function (c) {\n          return c.id;\n        }).indexOf(n) > -1;\n      }); _i < _b.length; _i++) {\n        var neighbor = _b[_i]; // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\n          allCycles.push((_a = {}, _a[node.id] = node, _a));\n        } else {\n          adjList[node.id].push(node2Idx[neighbor]);\n        }\n      }\n    }\n\n    return {\n      component: component,\n      adjList: adjList,\n      minIdx: minIdx\n    };\n  };\n\n  var nodeIdx = 0;\n\n  while (nodeIdx < nodes.length) {\n    var subgraphNodes = nodes.filter(function (n) {\n      return node2Idx[n.id] >= nodeIdx;\n    });\n    var sccs = (0, _connectedComponent.detectStrongConnectComponents)({\n      nodes: subgraphNodes,\n      edges: graphData.edges\n    }).filter(function (component) {\n      return component.length > 1;\n    });\n    if (sccs.length === 0) break;\n    var scc = getMinComponentAdj(sccs);\n    var minIdx = scc.minIdx,\n        adjList = scc.adjList,\n        component = scc.component;\n\n    if (component.length > 1) {\n      component.forEach(function (node) {\n        B[node.id] = new Set();\n      });\n      var startNode = idx2Node[minIdx]; // startNode 不在指定要包含的节点中，提前结束搜索\n\n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n\n  return allCycles;\n};\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\n\n\nexports.detectAllDirectedCycle = detectAllDirectedCycle;\n\nvar detectAllCycles = function detectAllCycles(graphData, directed, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\n};\n\nexports.detectAllCycles = detectAllCycles;\nvar _default = detectDirectedCycle;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = depthFirstSearch;\n\nvar _util = require(\"./util\");\n\nfunction initCallbacks(callbacks) {\n  if (callbacks === void 0) {\n    callbacks = {};\n  }\n\n  var initiatedCallback = callbacks;\n\n  var stubCallback = function stubCallback() {};\n\n  var allowTraversalCallback = function () {\n    var seen = {};\n    return function (_a) {\n      var next = _a.next;\n\n      if (!seen[next]) {\n        seen[next] = true;\n        return true;\n      }\n\n      return false;\n    };\n  }();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n  return initiatedCallback;\n}\n/**\n * @param {Graph} graph\n * @param {GraphNode} currentNode\n * @param {GraphNode} previousNode\n * @param {Callbacks} callbacks\n */\n\n\nfunction depthFirstSearchRecursive(graphData, currentNode, previousNode, callbacks) {\n  callbacks.enter({\n    current: currentNode,\n    previous: previousNode\n  });\n  var _a = graphData.edges,\n      edges = _a === void 0 ? [] : _a;\n  (0, _util.getNeighbors)(currentNode, edges, 'target').forEach(function (nextNode) {\n    if (callbacks.allowTraversal({\n      previous: previousNode,\n      current: currentNode,\n      next: nextNode\n    })) {\n      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);\n    }\n  });\n  callbacks.leave({\n    current: currentNode,\n    previous: previousNode\n  });\n}\n/**\n * 深度优先遍历图\n * @param data GraphData 图数据\n * @param startNodeId 开始遍历的节点的 ID\n * @param originalCallbacks 回调\n */\n\n\nfunction depthFirstSearch(graphData, startNodeId, callbacks) {\n  depthFirstSearchRecursive(graphData, startNodeId, '', initCallbacks(callbacks));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _util2 = require(\"./util\");\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nvar _default = dijkstra;\nexports.default = _default;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath), [target]));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAllPath = exports.findShortestPath = void 0;\n\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar findShortestPath = function findShortestPath(graphData, start, end, directed, weightPropertyName) {\n  var _a = (0, _dijkstra.default)(graphData, start, directed, weightPropertyName),\n      length = _a.length,\n      path = _a.path,\n      allPath = _a.allPath;\n\n  return {\n    length: length[end],\n    path: path[end],\n    allPath: allPath[end]\n  };\n};\n\nexports.findShortestPath = findShortestPath;\n\nvar findAllPath = function findAllPath(graphData, start, end, directed) {\n  var _a;\n\n  if (start === end) return [[start]];\n  var _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var visited = [start];\n  var isVisited = (_a = {}, _a[start] = true, _a);\n  var stack = []; // 辅助栈，用于存储访问过的节点的邻居节点\n\n  var allPath = [];\n  var neighbors = directed ? (0, _util.getNeighbors)(start, edges, 'target') : (0, _util.getNeighbors)(start, edges);\n  stack.push(neighbors);\n\n  while (visited.length > 0 && stack.length > 0) {\n    var children = stack[stack.length - 1];\n\n    if (children.length) {\n      var child = children.shift();\n\n      if (child) {\n        visited.push(child);\n        isVisited[child] = true;\n        neighbors = directed ? (0, _util.getNeighbors)(child, edges, 'target') : (0, _util.getNeighbors)(child, edges);\n        stack.push(neighbors.filter(function (neighbor) {\n          return !isVisited[neighbor];\n        }));\n      }\n    } else {\n      var node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n      continue;\n    }\n\n    if (visited[visited.length - 1] === end) {\n      var path = visited.map(function (node) {\n        return node;\n      });\n      allPath.push(path);\n      var node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n    }\n  }\n\n  return allPath;\n};\n\nexports.findAllPath = findAllPath;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar floydWarshall = function floydWarshall(graphData, directed) {\n  var adjacentMatrix = (0, _adjacentMatrix.default)(graphData, directed);\n  var dist = [];\n  var size = adjacentMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjacentMatrix[i][j] === 0 || !adjacentMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjacentMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n\nvar _default = floydWarshall;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = (0, _util.uniqueId)();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = sourceClusterId + \"---\" + targetClusterId;\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nvar _default = labelPropagation;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n\n  modularity *= 1 / param;\n  return modularity;\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\n\n\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {}; // the sum of the weights of all edges in the graph\n\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n\n  while (true) {\n    // whether to terminate the iterations\n    totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;\n    previousModularity = totalModularity;\n    iter++; // pre compute some values for current clusters\n\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n            target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    }); // move the nodes to increase the delta modularity\n\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster\n\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      }); // the modurarity for **removing** the node i from the origin cluster of node i\n\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam; // the neightbors of the node\n\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn\n\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return\n\n        if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster\n\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        }); // modurarity for **adding** node i into this neighbor cluster\n\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // the increase modurarity is the difference between addModurarity and removeModurarity\n\n        var increase = addModurarity - removeModurarity; // find the best cluster to move node i into\n\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      }); // if found a best cluster to move into\n\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id; // move the node to the best cluster\n\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster\n\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n              target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        }); // the nodes of the clusters to move into and remove are changed, update their sumTot\n\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  } // delete the empty clusters, assign increasing clusterId\n\n\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n      return;\n    }\n\n    var newId = String(clusterIdx + 1);\n\n    if (newId === clusterId) {\n      return;\n    }\n\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    clusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete clusters[clusterId];\n    clusterIdx++;\n  });\n  nodes.forEach(function (node) {\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = sourceClusterId + \"---\" + targetClusterId;\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nvar _default = louvain;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _unionFind = _interopRequireDefault(require(\"./structs/union-find\"));\n\nvar _binaryHeap = _interopRequireDefault(require(\"./structs/binary-heap\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new _binaryHeap.default(compareWeight);\n  (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      (0, _util.getEdgesByNodeId)(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      (0, _util.getEdgesByNodeId)(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new _unionFind.default(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nvar _default = minimumSpanningTree;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * 并查集 Disjoint set to support quick union\n */\nvar UnionFind =\n/** @class */\nfunction () {\n  function UnionFind(items) {\n    this.count = items.length;\n    this.parent = {};\n\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n      var i = items_1[_i];\n      this.parent[i] = i;\n    }\n  } // find the root of the item\n\n\n  UnionFind.prototype.find = function (item) {\n    while (this.parent[item] !== item) {\n      item = this.parent[item];\n    }\n\n    return item;\n  };\n\n  UnionFind.prototype.union = function (a, b) {\n    var rootA = this.find(a);\n    var rootB = this.find(b);\n    if (rootA === rootB) return; // make the element with smaller root the parent\n\n    if (rootA < rootB) {\n      if (this.parent[b] !== b) this.union(this.parent[b], a);\n      this.parent[b] = this.parent[a];\n    } else {\n      if (this.parent[a] !== a) this.union(this.parent[a], b);\n      this.parent[a] = this.parent[b];\n    }\n  }; // whether a and b are connected, i.e. a and b have the same root\n\n\n  UnionFind.prototype.connected = function (a, b) {\n    return this.find(a) === this.find(b);\n  };\n\n  return UnionFind;\n}();\n\nvar _default = UnionFind;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar defaultCompare = function defaultCompare(a, b) {\n  return a - b;\n};\n\nvar MinBinaryHeap =\n/** @class */\nfunction () {\n  function MinBinaryHeap(compareFn) {\n    if (compareFn === void 0) {\n      compareFn = defaultCompare;\n    }\n\n    this.compareFn = compareFn;\n    this.list = [];\n  }\n\n  MinBinaryHeap.prototype.getLeft = function (index) {\n    return 2 * index + 1;\n  };\n\n  MinBinaryHeap.prototype.getRight = function (index) {\n    return 2 * index + 2;\n  };\n\n  MinBinaryHeap.prototype.getParent = function (index) {\n    if (index === 0) {\n      return null;\n    }\n\n    return Math.floor((index - 1) / 2);\n  };\n\n  MinBinaryHeap.prototype.isEmpty = function () {\n    return this.list.length <= 0;\n  };\n\n  MinBinaryHeap.prototype.top = function () {\n    return this.isEmpty() ? undefined : this.list[0];\n  };\n\n  MinBinaryHeap.prototype.delMin = function () {\n    var top = this.top();\n    var bottom = this.list.pop();\n\n    if (this.list.length > 0) {\n      this.list[0] = bottom;\n      this.moveDown(0);\n    }\n\n    return top;\n  };\n\n  MinBinaryHeap.prototype.insert = function (value) {\n    if (value !== null) {\n      this.list.push(value);\n      var index = this.list.length - 1;\n      this.moveUp(index);\n      return true;\n    }\n\n    return false;\n  };\n\n  MinBinaryHeap.prototype.moveUp = function (index) {\n    var parent = this.getParent(index);\n\n    while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {\n      // swap\n      var tmp = this.list[parent];\n      this.list[parent] = this.list[index];\n      this.list[index] = tmp; // [this.list[index], this.list[parent]] = [this.list[parent], this.list[index]]\n\n      index = parent;\n      parent = this.getParent(index);\n    }\n  };\n\n  MinBinaryHeap.prototype.moveDown = function (index) {\n    var _a;\n\n    var element = index;\n    var left = this.getLeft(index);\n    var right = this.getRight(index);\n    var size = this.list.length;\n\n    if (left !== null && left < size && this.compareFn(this.list[element], this.list[left]) > 0) {\n      element = left;\n    } else if (right !== null && right < size && this.compareFn(this.list[element], this.list[right]) > 0) {\n      element = right;\n    }\n\n    if (index !== element) {\n      _a = [this.list[element], this.list[index]], this.list[index] = _a[0], this.list[element] = _a[1];\n      this.moveDown(element);\n    }\n  };\n\n  return MinBinaryHeap;\n}();\n\nvar _default = MinBinaryHeap;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _degree = _interopRequireDefault(require(\"./degree\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\nvar pageRank = function pageRank(graphData, epsilon, linkProb) {\n  if (typeof epsilon !== 'number') epsilon = 0.000001;\n  if (typeof linkProb !== 'number') linkProb = 0.85;\n  var distance = 1;\n  var leakedRank = 0;\n  var maxIterations = 1000;\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodesCount = nodes.length;\n  var currentRank;\n  var curRanks = {};\n  var prevRanks = {}; // Initialize pageranks 初始化\n\n  for (var j = 0; j < nodesCount; ++j) {\n    var node = nodes[j];\n    var nodeId = node.id;\n    curRanks[nodeId] = 1 / nodesCount;\n    prevRanks[nodeId] = 1 / nodesCount;\n  }\n\n  var nodeDegree = (0, _degree.default)(graphData);\n\n  while (maxIterations > 0 && distance > epsilon) {\n    leakedRank = 0;\n\n    for (var j = 0; j < nodesCount; ++j) {\n      var node = nodes[j];\n      var nodeId = node.id;\n      currentRank = 0;\n\n      if (nodeDegree[node.id].inDegree === 0) {\n        curRanks[nodeId] = 0;\n      } else {\n        var neighbors = (0, _util.getNeighbors)(nodeId, edges, 'source');\n\n        for (var i = 0; i < neighbors.length; ++i) {\n          var neighbor = neighbors[i];\n          var outDegree = nodeDegree[neighbor].outDegree;\n          if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;\n        }\n\n        curRanks[nodeId] = linkProb * currentRank;\n        leakedRank += curRanks[nodeId];\n      }\n    }\n\n    leakedRank = (1 - leakedRank) / nodesCount;\n    distance = 0;\n\n    for (var j = 0; j < nodesCount; ++j) {\n      var node = nodes[j];\n      var nodeId = node.id;\n      currentRank = curRanks[nodeId] + leakedRank;\n      distance += Math.abs(currentRank - prevRanks[nodeId]);\n      prevRanks[nodeId] = currentRank;\n    }\n\n    maxIterations -= 1;\n  }\n\n  return prevRanks;\n};\n\nvar _default = pageRank;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _floydWarshall = _interopRequireDefault(require(\"./floydWarshall\"));\n\nvar _gSpan = _interopRequireDefault(require(\"./gSpan/gSpan\"));\n\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (k === void 0) {\n    k = 2;\n  }\n\n  var units = [];\n  var nodes = graphData.nodes;\n  spm.forEach(function (row, i) {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\n  var unitNodeIdxs = [i];\n  var neighbors = [];\n  var labelCountMap = {};\n  row.forEach(function (v, j) {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      var label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = {\n        count: 1,\n        dists: [v]\n      };else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  }); // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n\n  Object.keys(labelCountMap).forEach(function (label) {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\n      return a - b;\n    });\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors: neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap\n  };\n};\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\n\n\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\n  // 每个节点需要随机找出的点对数\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  var nodePairMap = {};\n  var foundNodePairCount = 0; // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n\n  kNeighborUnits.forEach(function (unit, i) {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    var nodePairForICount = 0;\n    var outerLoopCount = 0;\n    var neighbors = unit.nodeIdxs; // the first one is the center node\n\n    var neighborNum = unit.neighborNum - 1;\n\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      var innerLoopCount = 0; // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n\n      while (nodePairMap[i + \"-\" + oidx] || nodePairMap[oidx + \"-\" + i]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[i + \"-\" + oidx] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx]\n        };\n        nodePairForICount++;\n        foundNodePairCount++; // 如果当前找到的点对数量达到了上限，返回结果\n\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    } // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n\n\n    if (nodePairForICount < nodePairNumEachNode) {\n      var gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\n\n\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\n  var nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(function (key) {\n    var _a, _b;\n\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = {\n      nodes: [],\n      edges: []\n    };\n    var pair = nodePairMap[key];\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n\n    var endSet = new Set(endUnitNodeIds);\n    var intersect = startUnitNodeIds.filter(function (x) {\n      return endSet.has(x);\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n\n    var intersectIdMap = {};\n    var intersectLength = intersect.length;\n\n    for (var i = 0; i < intersectLength; i++) {\n      var node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n\n      intersectIdMap[node.id] = true;\n    } // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n\n\n    graphData.edges.forEach(function (edge) {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\n\n\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\n  var nodeMap = {};\n  graph.nodes.forEach(function (node) {\n    nodeMap[node.id] = node;\n  });\n  var count = 0;\n  graph.edges.forEach(function (e) {\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\n    var strNodeLabel1 = structure.nodes[0][nodeLabelProp];\n    var strNodeLabel2 = structure.nodes[1][nodeLabelProp];\n    var strEdgeLabel = structure.edges[0][edgeLabelProp];\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\n      count++;\n    }\n  });\n  return count;\n};\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\n\n\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\n  var maxOffset = Infinity,\n      representClusterType = 0;\n\n  var _loop_1 = function _loop_1(i) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    var countMapI = matchedCountMap[i]; // 按照 value 为该组排序，生成 keys 的数组：\n\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\n      return countMapI[a] - countMapI[b];\n    }); // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n\n    var groupNum = 10;\n    var clusters = []; // 总共有 groupNum 个项\n\n    sortedGraphKeys.forEach(function (key, j) {\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\n        graphs: [],\n        totalCount: 0,\n        aveCount: 0\n      };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    }); // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n\n    var aveIntraDist = 0; // 该类的类内平均值\n\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n\n    clusters.forEach(function (graphsInCluster) {\n      // 类内均值\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount); // 对于每类，计算类内间距平均值\n\n      var aveIntraPerCluster = 0;\n      var graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\n        var graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n    aveIntraDist /= clusters.length; // 用类内均值计算类间距\n\n    var aveInterDist = 0; // 类间间距平均值\n\n    aveCounts.forEach(function (aveCount1, j) {\n      aveCounts.forEach(function (aveCount2, k) {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\n    }); // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n\n    var offset = aveInterDist - aveIntraDist;\n\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  };\n\n  for (var i = 0; i < structureNum; i++) {\n    _loop_1(i);\n  }\n\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType]\n  };\n};\n\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\n  var nodeMap = {},\n      nodeLabelMap = {};\n  nodes.forEach(function (node, i) {\n    nodeMap[node.id] = {\n      idx: i,\n      node: node,\n      degree: 0\n    };\n    var label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return {\n    nodeMap: nodeMap,\n    nodeLabelMap: nodeLabelMap\n  };\n};\n\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\n  var edgeMap = {},\n      edgeLabelMap = {};\n  edges.forEach(function (edge, i) {\n    edgeMap[\"\" + _util.uniqueId] = {\n      idx: i,\n      edge: edge\n    };\n    var label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n    var sourceNode = nodeMap[edge.source];\n    if (sourceNode) sourceNode.degree++;\n    var targetNode = nodeMap[edge.target];\n    if (targetNode) targetNode.degree++;\n  });\n  return {\n    edgeMap: edgeMap,\n    edgeLabelMap: edgeLabelMap\n  };\n};\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\n\n\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\n  var length = spm.length;\n  var map = {};\n  spm.forEach(function (row, i) {\n    var start = directed ? 0 : i + 1;\n    var iId = nodes[i].id;\n\n    for (var j = start; j < length; j++) {\n      if (i === j) continue;\n      var jId = nodes[j].id;\n      var dist = row[j];\n      map[iId + \"-\" + jId] = dist;\n      if (!directed) map[jId + \"-\" + iId] = dist;\n    }\n  });\n  return map;\n};\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\n\n\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\n  var _a;\n\n  var key = node1.id + \"-\" + node2.id;\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined; // 若没有缓存相交邻居诱导子图，计算\n\n  if (!interInducedGraph) {\n    var pairMap = (_a = {}, _a[key] = {\n      start: nodeMap[node1.id].idx,\n      end: nodeMap[node2.id].idx,\n      distance: spDist\n    }, _a);\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\n\n\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  if (!graphData || !graphData.nodes) return; // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n  // console.log(\"----- stage-pre: preprocessing -------\");\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n\n  var nodeNum = graphData.nodes.length;\n  if (!nodeNum) return; // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n\n  var spm = (0, _floydWarshall.default)(graphData, directed); // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n\n  var patternSpm = (0, _floydWarshall.default)(pattern, directed); // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n\n  var spmMap = getSpmMap(graphData.nodes, spm, directed); // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed); // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n\n  var _a = getNodeMaps(graphData.nodes, nodeLabelProp),\n      nodeMap = _a.nodeMap,\n      nodeLabelMap = _a.nodeLabelMap;\n\n  var _b = getNodeMaps(pattern.nodes, nodeLabelProp),\n      patternNodeMap = _b.nodeMap,\n      patternNodeLabelMap = _b.nodeLabelMap; // 计算节点度数\n\n\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap; // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n\n  if (!length) length = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpm[0]), [2]));\n  if (!k) k = length; // console.log(\"params\", directed, length, k);\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k); // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, patternKNeighborUnits, spm); // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData); // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n\n  var top = 10,\n      minSupport = 1,\n      minNodeNum = 1,\n      maxNodeNum = 4;\n  var params = {\n    graphs: intGMap,\n    nodeLabelProp: nodeLabelProp,\n    edgeLabelProp: edgeLabelProp,\n    minSupport: minSupport,\n    minNodeNum: minNodeNum,\n    maxNodeNum: maxNodeNum,\n    directed: directed\n  }; // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n\n  var freStructures = (0, _gSpan.default)(params).slice(0, top); // structureNum 可能小于 top\n\n  var structureNum = freStructures.length; // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n\n  var matchedCountMap = [];\n  freStructures.forEach(function (structure, i) {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(function (key) {\n      var graph = intGMap[key];\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  }); // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n\n  var _c = findRepresentStructure(matchedCountMap, structureNum, freStructures),\n      dsG = _c.structure,\n      ndsDist = _c.structureCountMap; // -------- 第二步，匹配-------\n  // 2.1 从 Q 中的第一个标签的第一个节点开始，寻找 G 中的匹配\n\n\n  var beginPNode = pattern.nodes[0];\n  var label = beginPNode[nodeLabelProp]; // 2.1.1 找到 G 中标签与之相同的节点\n\n  var candidates = nodeLabelMap[label]; // console.log(\"----- stage2: going to find candidates -------\");\n  // 全局缓存，避免重复计算\n\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n\n  var patternIntGraphMap = {},\n      patternNDSDist = {},\n      // key 为 node.id-node.id\n  patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n\n  var patternSpDist = {};\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\n    patternSpDist[label2] = [];\n    var maxDist = -Infinity;\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    var patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\n      var dist = patternSpmMap[beginPNode.id + \"-\" + nodeWithLabel2.id];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[beginPNode.id + \"-\" + nodeWithLabel2.id] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist\n      };\n    }); // spDist[label2] 按照从小到大排序\n\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\n      return a - b;\n    }); // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap); // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n\n    var currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(function (key) {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n\n      var patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    }); // 根据值为 currentPatternNDSDist 从大到小排序\n\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\n      return b - a;\n    });\n    patternNDSDistMap[beginPNode.id + \"-\" + label2] = currentPatternNDSDistArray;\n    if (label2 === label) return;\n    var candidatesNum = candidates.length;\n\n    var _loop_4 = function _loop_4(m) {\n      var cNode = candidates[m]; // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\n\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n\n\n      var prune2Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n\n\n      var cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\n        var dist = spmMap[cNode.id + \"-\" + neighborNode.id];\n        cNodePairMap[cNode.id + \"-\" + neighborNode.id] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist\n        };\n      }); // 更新 intGMap\n\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap); // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n\n      var currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(function (key) {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n\n        var intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      }); // 根据值为 currentNDSDistArray 从大到小排序\n\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\n        return b - a;\n      });\n      var prune3Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n    };\n\n    for (var m = candidatesNum - 1; m >= 0; m--) {\n      _loop_4(m);\n    }\n  });\n  var candidateGraphs = []; // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n\n  candidates.forEach(function (candidate) {\n    var nodeIdx = nodeMap[candidate.id].idx;\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\n    var neighborNodes = lengthNeighborUnit.neighbors; // 删除不可能找到匹配的邻居点\n\n    var neighborNum = neighborNodes.length;\n    var unmatched = false;\n\n    var _loop_5 = function _loop_5(i) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return {\n          value: void 0\n        };\n      }\n\n      var neighborNode = neighborNodes[i];\n      var neighborLabel = neighborNode[nodeLabelProp]; // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      }\n\n      var key = candidate.id + \"-\" + neighborNode.id; // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      } // prune2.2\n\n\n      var distToCandidate = spmMap[key];\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][patternSpDist[neighborLabel].length - 1]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      } // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n\n\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\n      var patternKey = beginPNode.id + \"-\" + neighborLabel;\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      } // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n\n\n      var minPatternNodeLabelDegree = minPatternNodeLabelDegreeMap[neighborLabel];\n\n      if (minPatternNodeLabelDegree === undefined) {\n        minPatternNodeLabelDegree = Infinity;\n        patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\n          var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n          if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\n        });\n        minPatternNodeLabelDegreeMap[neighborLabel] = minPatternNodeLabelDegree;\n      }\n\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        return \"continue\";\n      }\n    };\n\n    for (var i = neighborNum - 1; i >= 0; i--) {\n      var state_2 = _loop_5(i);\n\n      if (_typeof(state_2) === \"object\") return state_2.value;\n    } // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n\n\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes)\n      });\n    }\n  }); // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;\n  var undirectedLengthsToBeginPNodeLabelMap = {};\n\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\n        return a - b;\n      });\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  } // 现在 candidateGraphs 里面只有节点，进行边的筛选\n\n\n  var candidateGraphNum = candidateGraphs.length;\n\n  var _loop_2 = function _loop_2(i) {\n    var candidateGraph = candidateGraphs[i];\n    var candidate = candidateGraph.nodes[0];\n    var candidateNodeLabelCountMap = {};\n    var candidateNodeMap = {};\n    candidateGraph.nodes.forEach(function (node, q) {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node: node,\n        degree: 0\n      };\n      var cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\n    }); // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n\n    var candidateEdges = [];\n    var edgeLabelCountMap = {};\n    graphData.edges.forEach(function (edge) {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n      }\n    }); // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    var prunedByEdgeLabel = false;\n\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\n\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // 遍历 candidateEdges，进行边的筛选\n\n\n    var candidateEdgeNum = candidateEdges.length; // prune：若边数过少，去除该图\n\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"break\";\n    }\n\n    var candidateGraphInvalid = false;\n\n    var _loop_6 = function _loop_6(e) {\n      var edge = candidateEdges[e];\n      var edgeLabel = edge[edgeLabelProp];\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel]; // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        return \"continue\";\n      } // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n\n\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n      var edgeMatched = false;\n      patternEdgesWithLabel.forEach(function (patternEdge) {\n        var patternSource = patternNodeMap[patternEdge.source].node;\n        var patternTarget = patternNodeMap[patternEdge.target].node;\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\n      });\n\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        return \"continue\";\n      }\n    };\n\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\n      var state_3 = _loop_6(e);\n\n      if (state_3 === \"break\") break;\n    } // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    candidateGraph.edges = candidateEdges;\n    var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return; // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n\n      if (lengthsToCandidate[targetId] === Infinity) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n        return;\n      } // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n\n\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\n\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n      }\n    });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    var degreeChanged = true;\n    var loopCount = 0;\n\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false; // candidate 度数不足，删去该图\n\n      if (candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree) {\n        candidateGraphInvalid = true;\n        break;\n      } // candidate label 个数不足，删去该图\n\n\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\n        candidateGraphInvalid = true;\n        break;\n      } // prune6：去除度数过小的节点\n\n\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\n\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        var cgNode = candidateGraph.nodes[o];\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\n        var cNodeLabel = cgNode[nodeLabelProp];\n\n        if (nodeDegree < minPatternNodeLabelDegreeMap[cNodeLabel]) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--; // 节点 label 个数不足\n\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break; // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n\n      candidateEdgeNum = candidateEdges.length;\n\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\n        var cedge = candidateEdges[y];\n\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          var edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          candidateNodeMap[cedge.source] && candidateNodeMap[cedge.source].degree--;\n          candidateNodeMap[cedge.target] && candidateNodeMap[cedge.target].degree--; // 边 label 数量不足\n\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          degreeChanged = true;\n        }\n      }\n\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n\n\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n  };\n\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\n    var state_1 = _loop_2(i);\n\n    if (state_1 === \"break\") break;\n  } // 此时已经生成的多个 candidateGraphs，可能有重复\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n\n\n  var currentLength = candidateGraphs.length;\n\n  var _loop_3 = function _loop_3(i) {\n    var cg1 = candidateGraphs[i];\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n    cg1.edges.forEach(function (edge) {\n      var key = edge.source + \"-\" + edge.target + \"-\" + edge.label;\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\n    });\n\n    var _loop_7 = function _loop_7(j) {\n      var cg2 = candidateGraphs[j];\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n      cg2.edges.forEach(function (edge) {\n        var key = edge.source + \"-\" + edge.target + \"-\" + edge.label;\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\n      });\n      var same = true;\n\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(function (key) {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    };\n\n    for (var j = currentLength - 1; j > i; j--) {\n      _loop_7(j);\n    }\n\n    currentLength = candidateGraphs.length;\n  };\n\n  for (var i = 0; i <= currentLength - 1; i++) {\n    _loop_3(i);\n  }\n\n  return candidateGraphs;\n};\n\nvar _default = GADDI;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@antv/util\");\n\nvar _struct = require(\"./struct\");\n\nvar DFSedge =\n/** @class */\nfunction () {\n  function DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\n    this.fromNode = fromNode;\n    this.toNode = toNode;\n    this.nodeEdgeNodeLabel = {\n      nodeLabel1: fromNodeLabel || _struct.VACANT_NODE_LABEL,\n      edgeLabel: edgeLabel || _struct.VACANT_EDGE_LABEL,\n      nodeLabel2: toNodeLabel || _struct.VACANT_NODE_LABEL\n    };\n  }\n\n  DFSedge.prototype.equalTo = function (other) {\n    return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;\n  };\n\n  DFSedge.prototype.notEqualTo = function (other) {\n    return !this.equalTo(other);\n  };\n\n  return DFSedge;\n}(); // DFScode 是 DESedge 的数组\n\n\nvar DFScode =\n/** @class */\nfunction () {\n  function DFScode() {\n    this.rmpath = [];\n    this.dfsEdgeList = [];\n  }\n\n  DFScode.prototype.equalTo = function (other) {\n    var aLength = this.dfsEdgeList.length;\n    var bLength = other.length;\n    if (aLength !== bLength) return false;\n\n    for (var i = 0; i < aLength; i++) {\n      if (this.dfsEdgeList[i] !== other[i]) return false;\n    }\n\n    return true;\n  };\n\n  DFScode.prototype.notEqualTo = function (other) {\n    return !this.equalTo(other);\n  };\n  /** 增加一条 edge 到 DFScode */\n\n\n  DFScode.prototype.pushBack = function (fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\n    this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));\n    return this.dfsEdgeList;\n  };\n  /** 根据 dfs 构建图 */\n\n\n  DFScode.prototype.toGraph = function (graphId, directed) {\n    if (graphId === void 0) {\n      graphId = _struct.VACANT_GRAPH_ID;\n    }\n\n    if (directed === void 0) {\n      directed = false;\n    }\n\n    var graph = new _struct.Graph(graphId, true, directed);\n    this.dfsEdgeList.forEach(function (dfsEdge) {\n      var fromNodeId = dfsEdge.fromNode;\n      var toNodeId = dfsEdge.toNode;\n      var _a = dfsEdge.nodeEdgeNodeLabel,\n          nodeLabel1 = _a.nodeLabel1,\n          edgeLabel = _a.edgeLabel,\n          nodeLabel2 = _a.nodeLabel2;\n      if (nodeLabel1 !== _struct.VACANT_NODE_LABEL) graph.addNode(fromNodeId, nodeLabel1);\n      if (nodeLabel2 !== _struct.VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);\n      graph.addEdge(undefined, fromNodeId, toNodeId, edgeLabel);\n    });\n    return graph;\n  }; // 建立 rightmost path\n\n\n  DFScode.prototype.buildRmpath = function () {\n    this.rmpath = [];\n    var oldFrom = undefined;\n    var selfLength = this.dfsEdgeList.length;\n\n    for (var i = selfLength - 1; i >= 0; i--) {\n      var dfsEdge = this.dfsEdgeList[i];\n      var fromNodeIdx = dfsEdge.fromNode;\n      var toNodeIdx = dfsEdge.toNode;\n\n      if (fromNodeIdx < toNodeIdx && (oldFrom === undefined || toNodeIdx === oldFrom)) {\n        this.rmpath.push(i);\n        oldFrom = fromNodeIdx;\n      }\n    }\n\n    return this.rmpath;\n  };\n\n  DFScode.prototype.getNodeNum = function () {\n    var nodeMap = {};\n    this.dfsEdgeList.forEach(function (dfsEdge) {\n      if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;\n      if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;\n    });\n    return Object.keys(nodeMap).length;\n  };\n\n  return DFScode;\n}();\n\nvar History =\n/** @class */\nfunction () {\n  function History(pdfs) {\n    this.his = {};\n    this.nodesUsed = {};\n    this.edgesUsed = {};\n    this.edges = [];\n    if (!pdfs) return;\n\n    while (pdfs) {\n      var e = pdfs.edge;\n      this.edges.push(e);\n      this.nodesUsed[e.from] = 1;\n      this.nodesUsed[e.to] = 1;\n      this.edgesUsed[e.id] = 1;\n      pdfs = pdfs.preNode;\n    } // 倒序\n\n\n    this.edges = this.edges.reverse();\n  }\n\n  History.prototype.hasNode = function (node) {\n    return this.nodesUsed[node.id] === 1;\n  };\n\n  History.prototype.hasEdge = function (edge) {\n    return this.edgesUsed[edge.id] === 1;\n  };\n\n  return History;\n}();\n\nvar GSpan =\n/** @class */\nfunction () {\n  function GSpan(_a) {\n    var graphs = _a.graphs,\n        _b = _a.minSupport,\n        minSupport = _b === void 0 ? 2 : _b,\n        _c = _a.minNodeNum,\n        minNodeNum = _c === void 0 ? 1 : _c,\n        _d = _a.maxNodeNum,\n        maxNodeNum = _d === void 0 ? 4 : _d,\n        _e = _a.top,\n        top = _e === void 0 ? 10 : _e,\n        _f = _a.directed,\n        directed = _f === void 0 ? false : _f,\n        _g = _a.verbose,\n        verbose = _g === void 0 ? false : _g; // -------- 第零步，初始化-------\n\n    this.graphs = graphs;\n    this.dfsCode = new DFScode();\n    this.support = 0;\n    this.frequentSize1Subgraphs = [];\n    this.frequentSubgraphs = [];\n    this.minSupport = minSupport;\n    this.top = top;\n    this.directed = directed;\n    this.counter = 0; // TODO? timestamp = {}\n\n    this.maxNodeNum = maxNodeNum;\n    this.minNodeNum = minNodeNum;\n    this.verbose = verbose;\n    if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;\n    this.reportDF = []; // matrix\n  } // Line 352\n\n\n  GSpan.prototype.findForwardRootEdges = function (graph, fromNode) {\n    var _this = this;\n\n    var result = [];\n    var nodeMap = graph.nodeMap;\n    fromNode.edges.forEach(function (edge) {\n      if (_this.directed || fromNode.label <= nodeMap[edge.to].label) result.push(edge);\n    });\n    return result;\n  };\n\n  GSpan.prototype.findBackwardEdge = function (graph, edge1, edge2, history) {\n    if (!this.directed && edge1 === edge2) return null;\n    var nodeMap = graph.nodeMap;\n    var edge2To = nodeMap[edge2.to];\n    var edge2ToEdges = edge2To.edges;\n    var edgeLength = edge2ToEdges.length;\n\n    for (var i = 0; i < edgeLength; i++) {\n      var edge = edge2ToEdges[i];\n      if (history.hasEdge(edge) || edge.to !== edge1.from) continue;\n\n      if (!this.directed) {\n        if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {\n          return edge;\n        }\n      } else {\n        if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {\n          return edge;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GSpan.prototype.findForwardPureEdges = function (graph, rightmostEdge, minNodeLabel, history) {\n    var result = [];\n    var rightmostEdgeToId = rightmostEdge.to;\n    var edges = graph.nodeMap[rightmostEdgeToId].edges;\n    var edgeLength = edges.length;\n\n    for (var i = 0; i < edgeLength; i++) {\n      var edge = edges[i];\n      var toNode = graph.nodeMap[edge.to];\n\n      if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {\n        result.push(edge);\n      }\n    }\n\n    return result;\n  };\n\n  GSpan.prototype.findForwardRmpathEdges = function (graph, rightmostEdge, minNodeLabel, history) {\n    var result = [];\n    var nodeMap = graph.nodeMap;\n    var toNodeLabel = nodeMap[rightmostEdge.to].label;\n    var fromNode = nodeMap[rightmostEdge.from];\n    var edges = fromNode.edges;\n    var edgeLength = edges.length;\n\n    for (var i = 0; i < edgeLength; i++) {\n      var edge = edges[i];\n      var newToNodeLabel = nodeMap[edge.to].label;\n\n      if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {\n        continue;\n      }\n\n      if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {\n        result.push(edge);\n      }\n    }\n\n    return result;\n  };\n\n  GSpan.prototype.getSupport = function (projected) {\n    var graphMap = {};\n    projected.forEach(function (pro) {\n      if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;\n    });\n    return Object.keys(graphMap).length;\n  };\n\n  GSpan.prototype.findMinLabel = function (obj) {\n    var minLabel = undefined;\n    Object.keys(obj).forEach(function (nodeEdgeNodeLabel) {\n      var _a = obj[nodeEdgeNodeLabel],\n          nodeLabel1 = _a.nodeLabel1,\n          edgeLabel = _a.edgeLabel,\n          nodeLabel2 = _a.nodeLabel2;\n\n      if (!minLabel) {\n        minLabel = {\n          nodeLabel1: nodeLabel1,\n          edgeLabel: edgeLabel,\n          nodeLabel2: nodeLabel2\n        };\n        return;\n      }\n\n      if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {\n        minLabel = {\n          nodeLabel1: nodeLabel1,\n          edgeLabel: edgeLabel,\n          nodeLabel2: nodeLabel2\n        };\n      }\n    });\n    return minLabel;\n  };\n\n  GSpan.prototype.isMin = function () {\n    var _this = this;\n\n    var dfsCode = this.dfsCode;\n    if (this.verbose) console.log(\"isMin checking\", dfsCode);\n    if (dfsCode.dfsEdgeList.length === 1) return true;\n    var directed = this.directed;\n    var graph = dfsCode.toGraph(_struct.VACANT_GRAPH_ID, directed);\n    var nodeMap = graph.nodeMap;\n    var dfsCodeMin = new DFScode();\n    var root = {};\n    graph.nodes.forEach(function (node) {\n      var forwardEdges = _this.findForwardRootEdges(graph, node);\n\n      forwardEdges.forEach(function (edge) {\n        var otherNode = nodeMap[edge.to];\n        var nodeEdgeNodeLabel = node.label + \"-\" + edge.label + \"-\" + otherNode.label;\n        if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {\n          projected: [],\n          nodeLabel1: node.label,\n          edgeLabel: edge.label,\n          nodeLabel2: otherNode.label\n        };\n        var pdfs = {\n          graphId: graph.id,\n          edge: edge,\n          preNode: null\n        };\n        root[nodeEdgeNodeLabel].projected.push(pdfs);\n      });\n    }); // 比较 root 中每一项的 nodeEdgeNodeLabel 大小，按照 nodeLabel1、edgeLabe、nodeLabel2 的顺序比较\n\n    var minLabel = this.findMinLabel(root); // line 419\n\n    dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2)); // line 423\n\n    var projectIsMin = function projectIsMin(projected) {\n      // right most path\n      var rmpath = dfsCodeMin.buildRmpath();\n      var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\n      var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode; // node id\n\n      var backwardRoot = {};\n      var flag = false,\n          newTo = 0;\n      var end = directed ? -1 : 0; // 遍历到 1 还是到 0\n\n      var _loop_1 = function _loop_1(i) {\n        if (flag) return \"break\"; // line 435\n\n        projected.forEach(function (p) {\n          var history = new History(p);\n\n          var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i]], history.edges[rmpath[0]], history);\n\n          if (backwardEdge) {\n            // Line 441\n            if (!backwardRoot[backwardEdge.label]) {\n              backwardRoot[backwardEdge.label] = {\n                projected: [],\n                edgeLabel: backwardEdge.label\n              };\n            }\n\n            backwardRoot[backwardEdge.label].projected.push({\n              graphId: graph.id,\n              edge: backwardRoot,\n              preNode: p\n            });\n            newTo = dfsCodeMin.dfsEdgeList[rmpath[i]].fromNode;\n            flag = true;\n          }\n        });\n      };\n\n      for (var i = rmpath.length - 1; i > end; i--) {\n        var state_1 = _loop_1(i);\n\n        if (state_1 === \"break\") break;\n      }\n\n      if (flag) {\n        var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);\n\n        dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, _struct.VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, _struct.VACANT_NODE_LABEL));\n        var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;\n        if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1]) return false;\n        return projectIsMin(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);\n      }\n\n      var forwardRoot = {};\n      flag = false;\n      var newFrom = 0;\n      projected.forEach(function (p) {\n        var history = new History(p);\n\n        var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);\n\n        if (forwardPureEdges.length > 0) {\n          flag = true;\n          newFrom = maxToC;\n          forwardPureEdges.forEach(function (edge) {\n            var key = edge.label + \"-\" + nodeMap[edge.to].label;\n            if (!forwardRoot[key]) forwardRoot[key] = {\n              projected: [],\n              edgeLabel: edge.label,\n              nodeLabel2: nodeMap[edge.to].label\n            };\n            forwardRoot[key].projected.push({\n              graphId: graph.id,\n              edge: edge,\n              preNode: p\n            });\n          });\n        }\n      });\n      var pathLength = rmpath.length;\n\n      var _loop_2 = function _loop_2(i) {\n        if (flag) return \"break\";\n        var value = rmpath[i];\n        projected.forEach(function (p) {\n          var history = new History(p);\n\n          var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);\n\n          if (forwardRmpathEdges.length > 0) {\n            flag = true;\n            newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;\n            forwardRmpathEdges.forEach(function (edge) {\n              var key = edge.label + \"-\" + nodeMap[edge.to].label;\n              if (!forwardRoot[key]) forwardRoot[key] = {\n                projected: [],\n                edgeLabel: edge.label,\n                nodeLabel2: nodeMap[edge.to].label\n              };\n              forwardRoot[key].projected.push({\n                graphId: graph.id,\n                edge: edge,\n                preNode: p\n              });\n            });\n          }\n        });\n      };\n\n      for (var i = 0; i < pathLength; i++) {\n        var state_2 = _loop_2(i);\n\n        if (state_2 === \"break\") break;\n      }\n\n      if (!flag) return true;\n\n      var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);\n\n      dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, _struct.VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));\n      var idx = dfsCodeMin.dfsEdgeList.length - 1;\n      if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx]) return false;\n      return projectIsMin(forwardRoot[forwardMinEdgeNodeLabel.edgeLabel + \"-\" + forwardMinEdgeNodeLabel.nodeLabel2].projected);\n    };\n\n    var key = minLabel.nodeLabel1 + \"-\" + minLabel.edgeLabel + \"-\" + minLabel.nodeLabel2;\n    return projectIsMin(root[key].projected);\n  };\n\n  GSpan.prototype.report = function () {\n    if (this.dfsCode.getNodeNum() < this.minNodeNum) return;\n    this.counter++;\n    var graph = this.dfsCode.toGraph(this.counter, this.directed);\n    this.frequentSubgraphs.push((0, _util.clone)(graph));\n  };\n\n  GSpan.prototype.subGraphMining = function (projected) {\n    var _this = this;\n\n    var support = this.getSupport(projected);\n    if (support < this.minSupport) return;\n    if (!this.isMin()) return;\n    this.report();\n    var nodeNum = this.dfsCode.getNodeNum();\n    var rmpath = this.dfsCode.buildRmpath();\n    var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;\n    var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\n    var forwardRoot = {};\n    var backwardRoot = {};\n    projected.forEach(function (p) {\n      var graph = _this.graphs[p.graphId];\n      var nodeMap = graph.nodeMap;\n      var history = new History(p); // backward Line 526\n\n      for (var i = rmpath.length - 1; i >= 0; i--) {\n        var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i]], history.edges[rmpath[0]], history);\n\n        if (backwardEdge) {\n          var key = _this.dfsCode.dfsEdgeList[rmpath[i]].fromNode + \"-\" + backwardEdge.label;\n          if (!backwardRoot[key]) backwardRoot[key] = {\n            projected: [],\n            toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n            edgeLabel: backwardEdge.label\n          };\n          backwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge: backwardEdge,\n            preNode: p\n          });\n        }\n      } // pure forward\n\n\n      if (nodeNum >= _this.maxNodeNum) return;\n\n      var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);\n\n      forwardPureEdges.forEach(function (edge) {\n        var key = maxToC + \"-\" + edge.label + \"-\" + nodeMap[edge.to].label;\n        if (!forwardRoot[key]) forwardRoot[key] = {\n          projected: [],\n          fromNodeId: maxToC,\n          edgeLabel: edge.label,\n          nodeLabel2: nodeMap[edge.to].label\n        };\n        forwardRoot[key].projected.push({\n          graphId: p.graphId,\n          edge: edge,\n          preNode: p\n        });\n      });\n\n      var _loop_3 = function _loop_3(i) {\n        var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i]], minNodeLabel, history);\n\n        forwardRmpathEdges.forEach(function (edge) {\n          var key = _this.dfsCode.dfsEdgeList[rmpath[i]].fromNode + \"-\" + edge.label + \"-\" + nodeMap[edge.to].label;\n          if (!forwardRoot[key]) forwardRoot[key] = {\n            projected: [],\n            fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n            edgeLabel: edge.label,\n            nodeLabel2: nodeMap[edge.to].label\n          };\n          forwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge: edge,\n            preNode: p\n          });\n        });\n      }; // rmpath forward\n\n\n      for (var i = 0; i < rmpath.length; i++) {\n        _loop_3(i);\n      }\n    }); // backward\n\n    Object.keys(backwardRoot).forEach(function (key) {\n      var _a = backwardRoot[key],\n          toNodeId = _a.toNodeId,\n          edgeLabel = _a.edgeLabel;\n\n      _this.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, \"-1\", edgeLabel, \"-1\"));\n\n      _this.subGraphMining(backwardRoot[key].projected);\n\n      _this.dfsCode.dfsEdgeList.pop();\n    }); // forward\n\n    Object.keys(forwardRoot).forEach(function (key) {\n      var _a = forwardRoot[key],\n          fromNodeId = _a.fromNodeId,\n          edgeLabel = _a.edgeLabel,\n          nodeLabel2 = _a.nodeLabel2;\n\n      _this.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, _struct.VACANT_NODE_LABEL, edgeLabel, nodeLabel2));\n\n      _this.subGraphMining(forwardRoot[key].projected);\n\n      _this.dfsCode.dfsEdgeList.pop();\n    });\n  };\n\n  GSpan.prototype.generate1EdgeFrequentSubGraphs = function () {\n    var graphs = this.graphs;\n    var directed = this.directed;\n    var minSupport = this.minSupport;\n    var frequentSize1Subgraphs = this.frequentSize1Subgraphs;\n    var nodeLabelCounter = {},\n        nodeEdgeNodeCounter = {}; // 保存各个图和各自节点的关系 map，key 格式为 graphKey-node类型\n\n    var nodeLableCounted = {}; // 保存各个图和各自边的关系 map，key 格式为 graphKey-fromNode类型-edge类型-toNode类型\n\n    var nodeEdgeNodeLabelCounted = {};\n    Object.keys(graphs).forEach(function (key) {\n      // Line 271\n      var graph = graphs[key];\n      var nodeMap = graph.nodeMap; // 遍历节点，记录对应图 与 每个节点的 label 到 nodeLableCounted\n\n      graph.nodes.forEach(function (node, i) {\n        // Line 272\n        var nodeLabel = node.label;\n        var graphNodeKey = key + \"-\" + nodeLabel;\n\n        if (!nodeLableCounted[graphNodeKey]) {\n          var counter = nodeLabelCounter[nodeLabel] || 0;\n          counter++;\n          nodeLabelCounter[nodeLabel] = counter;\n        }\n\n        nodeLableCounted[graphNodeKey] = {\n          graphKey: key,\n          label: nodeLabel\n        }; // 遍历该节点的所有边，记录各个图和各自边的关系到 nodeEdgeNodeLabelCounted. Line 276\n\n        node.edges.forEach(function (edge) {\n          var nodeLabel1 = nodeLabel;\n          var nodeLabel2 = nodeMap[edge.to].label;\n\n          if (!directed && nodeLabel1 > nodeLabel2) {\n            var tmp = nodeLabel2;\n            nodeLabel2 = nodeLabel1;\n            nodeLabel1 = tmp;\n          }\n\n          var edgeLabel = edge.label;\n          var graphNodeEdgeNodeKey = key + \"-\" + nodeLabel1 + \"-\" + edgeLabel + \"-\" + nodeLabel2;\n          var nodeEdgeNodeKey = nodeLabel1 + \"-\" + edgeLabel + \"-\" + nodeLabel2;\n\n          if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {\n            var counter = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;\n            counter++;\n            nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter; // Line281\n          }\n\n          nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {\n            graphId: key,\n            nodeLabel1: nodeLabel1,\n            edgeLabel: edgeLabel,\n            nodeLabel2: nodeLabel2\n          };\n        });\n      });\n    }); // 计算频繁的节点\n\n    Object.keys(nodeLabelCounter).forEach(function (label) {\n      var count = nodeLabelCounter[label];\n      if (count < minSupport) return;\n      var g = {\n        nodes: [],\n        edges: []\n      };\n      g.nodes.push({\n        id: \"0\",\n        label: label\n      });\n      frequentSize1Subgraphs.push(g); // if (minNodeNum <= 1) reportSize1 TODO\n    });\n    return frequentSize1Subgraphs;\n  };\n\n  GSpan.prototype.run = function () {\n    var _this = this; // -------- 第一步, _generate_1edge_frequent_subgraphs：频繁的单个节点-------\n\n\n    this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();\n    if (this.maxNodeNum < 2) return;\n    var graphs = this.graphs;\n    var directed = this.directed; // PDFS 数组的 map Line 304\n\n    var root = {};\n    Object.keys(graphs).forEach(function (graphId) {\n      var graph = graphs[graphId];\n      var nodeMap = graph.nodeMap; // Line 306\n\n      graph.nodes.forEach(function (node) {\n        var forwardRootEdges = _this.findForwardRootEdges(graph, node); // Line 308\n\n\n        forwardRootEdges.forEach(function (edge) {\n          var toNode = nodeMap[edge.to];\n          var nodeEdgeNodeLabel = node.label + \"-\" + edge.label + \"-\" + toNode.label;\n          if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {\n            projected: [],\n            nodeLabel1: node.label,\n            edgeLabel: edge.label,\n            nodeLabel2: toNode.label\n          };\n          var pdfs = {\n            graphId: graphId,\n            edge: edge,\n            preNode: null\n          };\n          root[nodeEdgeNodeLabel].projected.push(pdfs);\n        });\n      });\n    }); // Line 313\n\n    Object.keys(root).forEach(function (nodeEdgeNodeLabel) {\n      var _a = root[nodeEdgeNodeLabel],\n          projected = _a.projected,\n          nodeLabel1 = _a.nodeLabel1,\n          edgeLabel = _a.edgeLabel,\n          nodeLabel2 = _a.nodeLabel2;\n\n      _this.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));\n\n      _this.subGraphMining(projected);\n\n      _this.dfsCode.dfsEdgeList.pop();\n    });\n  };\n\n  return GSpan;\n}();\n\nvar formatGraphs = function formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp) {\n  var result = {};\n  Object.keys(graphs).forEach(function (key, i) {\n    var graph = graphs[key];\n    var fGraph = new _struct.Graph(i, true, directed);\n    var nodeIdxMap = {};\n    graph.nodes.forEach(function (node, j) {\n      fGraph.addNode(j, node[nodeLabelProp]);\n      nodeIdxMap[node.id] = j;\n    });\n    graph.edges.forEach(function (edge, k) {\n      var sourceIdx = nodeIdxMap[edge.source];\n      var targetIdx = nodeIdxMap[edge.target];\n      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);\n    });\n    if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;\n  });\n  return result;\n};\n\nvar toGraphDatas = function toGraphDatas(graphs, nodeLabelProp, edgeLabelProp) {\n  var result = [];\n  graphs.forEach(function (graph) {\n    var graphData = {\n      nodes: [],\n      edges: []\n    };\n    graph.nodes.forEach(function (node) {\n      var _a;\n\n      graphData.nodes.push((_a = {\n        id: \"\" + node.id\n      }, _a[nodeLabelProp] = node.label, _a));\n    });\n    graph.edges.forEach(function (edge) {\n      var _a;\n\n      graphData.edges.push((_a = {\n        source: \"\" + edge.from,\n        target: \"\" + edge.to\n      }, _a[edgeLabelProp] = edge.label, _a));\n    });\n    result.push(graphData);\n  });\n  return result;\n};\n\nvar DEFAULT_LABEL_NAME = \"cluster\";\n/**\n * gSpan 频繁子图计算算法（frequent graph mining）\n * @param params 参数\n */\n\nvar gSpan = function gSpan(params) {\n  // ------- 将图数据 GraphData 的 map 转换为格式 -------\n  var graphs = params.graphs,\n      _a = params.directed,\n      directed = _a === void 0 ? false : _a,\n      _b = params.nodeLabelProp,\n      nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME : _b,\n      _c = params.edgeLabelProp,\n      edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME : _c;\n  var formattedGraphs = formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp);\n  var minSupport = params.minSupport,\n      maxNodeNum = params.maxNodeNum,\n      minNodeNum = params.minNodeNum,\n      verbose = params.verbose,\n      top = params.top; // ------- 初始化与执行算法 -------\n\n  var algoParams = {\n    graphs: formattedGraphs,\n    minSupport: minSupport,\n    maxNodeNum: maxNodeNum,\n    minNodeNum: minNodeNum,\n    top: top,\n    verbose: verbose,\n    directed: directed\n  };\n  var calculator = new GSpan(algoParams);\n  calculator.run();\n  var result = toGraphDatas(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);\n  return result;\n};\n\nvar _default = gSpan;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Graph = exports.Node = exports.Edge = exports.AUTO_EDGE_ID = exports.VACANT_GRAPH_ID = exports.VACANT_NODE_LABEL = exports.VACANT_EDGE_LABEL = exports.VACANT_NODE_ID = exports.VACANT_EDGE_ID = void 0;\nvar VACANT_EDGE_ID = -1;\nexports.VACANT_EDGE_ID = VACANT_EDGE_ID;\nvar VACANT_NODE_ID = -1;\nexports.VACANT_NODE_ID = VACANT_NODE_ID;\nvar VACANT_EDGE_LABEL = \"-1\";\nexports.VACANT_EDGE_LABEL = VACANT_EDGE_LABEL;\nvar VACANT_NODE_LABEL = \"-1\";\nexports.VACANT_NODE_LABEL = VACANT_NODE_LABEL;\nvar VACANT_GRAPH_ID = -1;\nexports.VACANT_GRAPH_ID = VACANT_GRAPH_ID;\nvar AUTO_EDGE_ID = \"-1\";\nexports.AUTO_EDGE_ID = AUTO_EDGE_ID;\n\nvar Edge =\n/** @class */\nfunction () {\n  function Edge(id, from, to, label) {\n    if (id === void 0) {\n      id = VACANT_EDGE_ID;\n    }\n\n    if (from === void 0) {\n      from = VACANT_NODE_ID;\n    }\n\n    if (to === void 0) {\n      to = VACANT_NODE_ID;\n    }\n\n    if (label === void 0) {\n      label = VACANT_EDGE_LABEL;\n    }\n\n    this.id = id;\n    this.from = from;\n    this.to = to;\n    this.label = label;\n  }\n\n  return Edge;\n}();\n\nexports.Edge = Edge;\n\nvar Node =\n/** @class */\nfunction () {\n  function Node(id, label) {\n    if (id === void 0) {\n      id = VACANT_NODE_ID;\n    }\n\n    if (label === void 0) {\n      label = VACANT_NODE_LABEL;\n    }\n\n    this.id = id;\n    this.label = label;\n    this.edges = [];\n    this.edgeMap = {};\n  }\n\n  Node.prototype.addEdge = function (edge) {\n    this.edges.push(edge);\n    this.edgeMap[edge.id] = edge;\n  };\n\n  return Node;\n}();\n\nexports.Node = Node;\n\nvar Graph =\n/** @class */\nfunction () {\n  function Graph(id, edgeIdAutoIncrease, directed) {\n    if (id === void 0) {\n      id = VACANT_NODE_ID;\n    }\n\n    if (edgeIdAutoIncrease === void 0) {\n      edgeIdAutoIncrease = true;\n    }\n\n    if (directed === void 0) {\n      directed = false;\n    }\n\n    this.id = id;\n    this.edgeIdAutoIncrease = edgeIdAutoIncrease;\n    this.edges = [];\n    this.nodes = [];\n    this.nodeMap = {};\n    this.edgeMap = {};\n    this.nodeLabelMap = {};\n    this.edgeLabelMap = {};\n    this.counter = 0;\n    this.directed = directed;\n  }\n\n  Graph.prototype.getNodeNum = function () {\n    return this.nodes.length;\n  };\n\n  Graph.prototype.addNode = function (id, label) {\n    if (this.nodeMap[id]) return;\n    var node = new Node(id, label);\n    this.nodes.push(node);\n    this.nodeMap[id] = node;\n    if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];\n    this.nodeLabelMap[label].push(id);\n  };\n\n  Graph.prototype.addEdge = function (id, from, to, label) {\n    if (this.edgeIdAutoIncrease || id === undefined) id = this.counter++;\n    if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id]) return;\n    var edge = new Edge(id, from, to, label);\n    this.edges.push(edge);\n    this.edgeMap[id] = edge;\n    this.nodeMap[from].addEdge(edge);\n    if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];\n    this.edgeLabelMap[label].push(edge);\n\n    if (!this.directed) {\n      var rEdge = new Edge(id, to, from, label);\n      this.nodeMap[to].addEdge(rEdge);\n      this.edgeLabelMap[label].push(rEdge);\n    }\n  };\n\n  return Graph;\n}();\n\nexports.Graph = Graph;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _linkedList = _interopRequireDefault(require(\"./linked-list\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Stack =\n/** @class */\nfunction () {\n  function Stack(maxStep) {\n    if (maxStep === void 0) {\n      maxStep = 10;\n    }\n\n    this.linkedList = new _linkedList.default();\n    this.maxStep = maxStep;\n  }\n\n  Object.defineProperty(Stack.prototype, \"length\", {\n    get: function get() {\n      return this.linkedList.toArray().length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * 判断栈是否为空，如果链表中没有头部元素，则栈为空\n   */\n\n  Stack.prototype.isEmpty = function () {\n    return !this.linkedList.head;\n  };\n  /**\n   * 是否到定义的栈的最大长度，如果达到最大长度后，不再允许入栈\n   */\n\n\n  Stack.prototype.isMaxStack = function () {\n    return this.toArray().length >= this.maxStep;\n  };\n  /**\n   * 访问顶端元素\n   */\n\n\n  Stack.prototype.peek = function () {\n    if (this.isEmpty()) {\n      return null;\n    } // 返回头部元素，不删除元素\n\n\n    return this.linkedList.head.value;\n  };\n\n  Stack.prototype.push = function (value) {\n    this.linkedList.prepend(value);\n\n    if (this.length > this.maxStep) {\n      this.linkedList.deleteTail();\n    }\n  };\n\n  Stack.prototype.pop = function () {\n    var removeHead = this.linkedList.deleteHead();\n    return removeHead ? removeHead.value : null;\n  };\n\n  Stack.prototype.toArray = function () {\n    return this.linkedList.toArray().map(function (node) {\n      return node.value;\n    });\n  };\n\n  Stack.prototype.clear = function () {\n    while (!this.isEmpty()) {\n      this.pop();\n    }\n  };\n\n  return Stack;\n}();\n\nvar _default = Stack;\nexports.default = _default;"]}