{"version":3,"sources":["index.js","shape/index.js","shape/base.js","util/util.js","util/time.js","util/draw.js","util/parse.js","util/arc-params.js","util/arrow.js","group.js","shape/circle.js","shape/ellipse.js","shape/image.js","shape/line.js","util/in-stroke/line.js","shape/marker.js","shape/path.js","util/in-path/polygon.js","util/path.js","util/in-stroke/arc.js","shape/polygon.js","util/in-stroke/polyline.js","shape/polyline.js","shape/rect.js","util/in-stroke/rect.js","util/in-stroke/rect-radius.js","shape/text.js","canvas.js","util/hit.js","events.js","util/mini-canvas-proxy.js","patch/index.js","patch/bbox/index.js","patch/bbox/text.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AGTA,ADGA;AHUA,AENA,ADGA,AGTA,ADGA;AHUA,AENA,ADGA,AGTA,ADGA;ADIA,ADGA,AIZA,ADGA,ADGA;ADIA,ADGA,AIZA,ADGA,ADGA;ADIA,ADGA,AIZA,ADGA,ADGA;ADIA,ADGA,AIZA,ACHA,AFMA,ADGA;ADIA,ADGA,AIZA,ACHA,AFMA,ADGA;ADIA,ADGA,AIZA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,AFMA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,AFMA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,AFMA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AKfA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,AHSA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,AHSA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,AHSA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,AJYA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,AJYA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,AJYA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ALeA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ALeA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ALeA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AS3BA,ARwBA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ARwBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ARwBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ARwBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AbuCA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AbuCA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,Af6CA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,Af6CA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,Af6CA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,AGTA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AGTA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AGTA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AKfA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AKfA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AsBlEA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AsBlEA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AsBlEA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ADGA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ADGA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ADGA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,AFMA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,AFMA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,AFMA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,A/B6FA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA;AsBjEA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = exports.getArcParams = exports.Shape = exports.Group = exports.Canvas = void 0;\nvar tslib_1 = require(\"tslib\");\nvar Shape = require(\"./shape\");\nexports.Shape = Shape;\ntslib_1.__exportStar(require(\"@antv/g-base\"), exports);\nvar canvas_1 = require(\"./canvas\");\nObject.defineProperty(exports, \"Canvas\", { enumerable: true, get: function () { return canvas_1.default; } });\nvar group_1 = require(\"./group\");\nObject.defineProperty(exports, \"Group\", { enumerable: true, get: function () { return group_1.default; } });\nvar arc_params_1 = require(\"./util/arc-params\");\nObject.defineProperty(exports, \"getArcParams\", { enumerable: true, get: function () { return arc_params_1.default; } });\nexports.version = '0.5.6';\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Text = exports.Rect = exports.Polyline = exports.Polygon = exports.Path = exports.Marker = exports.Line = exports.Image = exports.Ellipse = exports.Circle = exports.Base = void 0;\nvar base_1 = require(\"./base\");\nObject.defineProperty(exports, \"Base\", { enumerable: true, get: function () { return base_1.default; } });\nvar circle_1 = require(\"./circle\");\nObject.defineProperty(exports, \"Circle\", { enumerable: true, get: function () { return circle_1.default; } });\nvar ellipse_1 = require(\"./ellipse\");\nObject.defineProperty(exports, \"Ellipse\", { enumerable: true, get: function () { return ellipse_1.default; } });\nvar image_1 = require(\"./image\");\nObject.defineProperty(exports, \"Image\", { enumerable: true, get: function () { return image_1.default; } });\nvar line_1 = require(\"./line\");\nObject.defineProperty(exports, \"Line\", { enumerable: true, get: function () { return line_1.default; } });\nvar marker_1 = require(\"./marker\");\nObject.defineProperty(exports, \"Marker\", { enumerable: true, get: function () { return marker_1.default; } });\nvar path_1 = require(\"./path\");\nObject.defineProperty(exports, \"Path\", { enumerable: true, get: function () { return path_1.default; } });\nvar polygon_1 = require(\"./polygon\");\nObject.defineProperty(exports, \"Polygon\", { enumerable: true, get: function () { return polygon_1.default; } });\nvar polyline_1 = require(\"./polyline\");\nObject.defineProperty(exports, \"Polyline\", { enumerable: true, get: function () { return polyline_1.default; } });\nvar rect_1 = require(\"./rect\");\nObject.defineProperty(exports, \"Rect\", { enumerable: true, get: function () { return rect_1.default; } });\nvar text_1 = require(\"./text\");\nObject.defineProperty(exports, \"Text\", { enumerable: true, get: function () { return text_1.default; } });\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar g_base_1 = require(\"@antv/g-base\");\nvar util_1 = require(\"../util/util\");\nvar draw_1 = require(\"../util/draw\");\nvar g_base_2 = require(\"@antv/g-base\");\nvar Shape = require(\"./index\");\nvar group_1 = require(\"../group\");\nvar ShapeBase = /** @class */ (function (_super) {\n    tslib_1.__extends(ShapeBase, _super);\n    function ShapeBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ShapeBase.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        // 设置默认值\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });\n    };\n    ShapeBase.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    ShapeBase.prototype.getGroupBase = function () {\n        return group_1.default;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    ShapeBase.prototype.onCanvasChange = function (changeType) {\n        draw_1.refreshElement(this, changeType);\n    };\n    ShapeBase.prototype.calculateBBox = function () {\n        var type = this.get('type');\n        var lineWidth = this.getHitLineWidth();\n        // const attrs = this.attr();\n        var bboxMethod = g_base_2.getBBoxMethod(type);\n        var box = bboxMethod(this);\n        var halfLineWidth = lineWidth / 2;\n        var minX = box.x - halfLineWidth;\n        var minY = box.y - halfLineWidth;\n        var maxX = box.x + box.width + halfLineWidth;\n        var maxY = box.y + box.height + halfLineWidth;\n        return {\n            x: minX,\n            minX: minX,\n            y: minY,\n            minY: minY,\n            width: box.width + lineWidth,\n            height: box.height + lineWidth,\n            maxX: maxX,\n            maxY: maxY,\n        };\n    };\n    ShapeBase.prototype.isFill = function () {\n        return !!this.attrs['fill'] || this.isClipShape();\n    };\n    ShapeBase.prototype.isStroke = function () {\n        return !!this.attrs['stroke'];\n    };\n    // 同 shape 中的方法重复了\n    ShapeBase.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            // 将 clip 的属性挂载到 context 上\n            draw_1.applyAttrsToContext(context, clip);\n            // 绘制 clip 路径\n            clip.createPath(context);\n            context.restore();\n            // 裁剪\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    // 绘制图形时需要考虑 region 限制\n    ShapeBase.prototype.draw = function (context, region) {\n        var clip = this.cfg.clipShape;\n        // 如果指定了 region，同时不允许刷新时，直接返回\n        if (region) {\n            if (this.cfg.refresh === false) {\n                // this._afterDraw();\n                this.set('hasChanged', false);\n                return;\n            }\n            // 是否相交需要考虑 clip 的包围盒\n            var bbox = this.getCanvasBBox();\n            if (!util_1.intersectRect(region, bbox)) {\n                // 图形的包围盒与重绘区域不相交时，也需要清除标记\n                this.set('hasChanged', false);\n                // 存在多种情形需要更新 cacheCanvasBBox 和 isInview 的判定\n                // 1. 之前图形在视窗内，但是现在不再视窗内\n                // 2. 如果当前的图形以及父元素都没有发生过变化，refresh = false 不会走到这里，所以这里的图形都是父元素发生变化，但是没有在视图内的元素\n                if (this.cfg.isInView) {\n                    this._afterDraw();\n                }\n                return;\n            }\n        }\n        context.save();\n        // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n        draw_1.applyAttrsToContext(context, this);\n        this._applyClip(context, clip);\n        this.drawPath(context);\n        context.restore();\n        this._afterDraw();\n    };\n    ShapeBase.prototype.getCanvasViewBox = function () {\n        var canvas = this.cfg.canvas;\n        if (canvas) {\n            // @ts-ignore\n            return canvas.getViewRange();\n        }\n        return null;\n    };\n    ShapeBase.prototype.cacheCanvasBBox = function () {\n        var canvasBBox = this.getCanvasViewBox();\n        // 绘制的时候缓存包围盒\n        if (canvasBBox) {\n            var bbox = this.getCanvasBBox();\n            var isInView = util_1.intersectRect(bbox, canvasBBox);\n            this.set('isInView', isInView);\n            // 不再视窗内 cacheCanvasBBox 设置成 null，会提升局部渲染的性能，\n            // 因为在局部渲染影响的包围盒计算时不考虑这个图形的包围盒\n            // 父元素 cacheCanvasBBox 计算的时候也不计算\n            if (isInView) {\n                this.set('cacheCanvasBBox', bbox);\n            }\n            else {\n                this.set('cacheCanvasBBox', null);\n            }\n        }\n    };\n    ShapeBase.prototype._afterDraw = function () {\n        this.cacheCanvasBBox();\n        // 绘制后消除标记\n        this.set('hasChanged', false);\n        this.set('refresh', null);\n    };\n    ShapeBase.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('isInView', null);\n        this.set('hasChanged', false);\n    };\n    /**\n     * 绘制图形的路径\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.drawPath = function (context) {\n        this.createPath(context);\n        this.strokeAndFill(context);\n        this.afterDrawPath(context);\n    };\n    /**\n     * @protected\n     * 填充图形\n     * @param {CanvasRenderingContext2D} context context 上下文\n     */\n    ShapeBase.prototype.fill = function (context) {\n        context.fill();\n    };\n    /**\n     * @protected\n     * 绘制图形边框\n     * @param {CanvasRenderingContext2D} context context 上下文\n     */\n    ShapeBase.prototype.stroke = function (context) {\n        context.stroke();\n    };\n    // 绘制或者填充\n    ShapeBase.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isFill()) {\n            if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = strokeOpacity;\n                }\n                this.stroke(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    /**\n     * @protected\n     * 绘制图形的路径\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.createPath = function (context) { };\n    /**\n     * 绘制完成 path 后的操作\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.afterDrawPath = function (context) { };\n    ShapeBase.prototype.isInShape = function (refX, refY) {\n        // return HitUtil.isHitShape(this, refX, refY);\n        var isStroke = this.isStroke();\n        var isFill = this.isFill();\n        var lineWidth = this.getHitLineWidth();\n        return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\n    };\n    // 之所以不拆成 isInStroke 和 isInPath 在于两者存在一些共同的计算\n    ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        return false;\n    };\n    /**\n     * 获取线拾取的宽度\n     * @returns {number} 线的拾取宽度\n     */\n    ShapeBase.prototype.getHitLineWidth = function () {\n        if (!this.isStroke()) {\n            return 0;\n        }\n        var attrs = this.attrs;\n        return attrs['lineWidth'] + attrs['lineAppendWidth'];\n    };\n    return ShapeBase;\n}(g_base_1.AbstractShape));\nexports.default = ShapeBase;\n//# sourceMappingURL=base.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isParent = exports.tick = exports.clearAnimationFrame = exports.requestAnimationFrame = exports.isNumberEqual = exports.mod = exports.toRadian = exports.each = exports.isArray = exports.isFunction = exports.isString = exports.isNil = exports.isSamePoint = exports.mergeRegion = exports.intersectRect = exports.inBox = exports.distance = exports.getPixelRatio = void 0;\nfunction getPixelRatio() {\n    return typeof window === 'object' && window.devicePixelRatio ? window.devicePixelRatio : 1;\n}\nexports.getPixelRatio = getPixelRatio;\n/**\n * 两点之间的距离\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 结束点 x\n * @param {number} y2 结束点 y\n */\nfunction distance(x1, y1, x2, y2) {\n    var dx = x1 - x2;\n    var dy = y1 - y2;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nexports.distance = distance;\n/**\n * 是否在包围盒内\n * @param {number} minX   包围盒开始的点 x\n * @param {number} minY   包围盒开始的点 y\n * @param {number} width  宽度\n * @param {number} height 高度\n * @param {[type]} x      检测点的 x\n * @param {[type]} y      监测点的 y\n */\nfunction inBox(minX, minY, width, height, x, y) {\n    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\n}\nexports.inBox = inBox;\nfunction intersectRect(box1, box2) {\n    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\nexports.intersectRect = intersectRect;\n// 合并两个区域\nfunction mergeRegion(region1, region2) {\n    if (!region1 || !region2) {\n        return region1 || region2;\n    }\n    return {\n        minX: Math.min(region1.minX, region2.minX),\n        minY: Math.min(region1.minY, region2.minY),\n        maxX: Math.max(region1.maxX, region2.maxX),\n        maxY: Math.max(region1.maxY, region2.maxY),\n    };\n}\nexports.mergeRegion = mergeRegion;\n/**\n * 判断两个点是否重合，点坐标的格式为 [x, y]\n * @param {Array} point1 第一个点\n * @param {Array} point2 第二个点\n */\nfunction isSamePoint(point1, point2) {\n    return point1[0] === point2[0] && point1[1] === point2[1];\n}\nexports.isSamePoint = isSamePoint;\nvar util_1 = require(\"@antv/util\");\nObject.defineProperty(exports, \"isNil\", { enumerable: true, get: function () { return util_1.isNil; } });\nObject.defineProperty(exports, \"isString\", { enumerable: true, get: function () { return util_1.isString; } });\nObject.defineProperty(exports, \"isFunction\", { enumerable: true, get: function () { return util_1.isFunction; } });\nObject.defineProperty(exports, \"isArray\", { enumerable: true, get: function () { return util_1.isArray; } });\nObject.defineProperty(exports, \"each\", { enumerable: true, get: function () { return util_1.each; } });\nObject.defineProperty(exports, \"toRadian\", { enumerable: true, get: function () { return util_1.toRadian; } });\nObject.defineProperty(exports, \"mod\", { enumerable: true, get: function () { return util_1.mod; } });\nObject.defineProperty(exports, \"isNumberEqual\", { enumerable: true, get: function () { return util_1.isNumberEqual; } });\nvar time_1 = require(\"./time\");\nObject.defineProperty(exports, \"requestAnimationFrame\", { enumerable: true, get: function () { return time_1.requestAnimationFrame; } });\nObject.defineProperty(exports, \"clearAnimationFrame\", { enumerable: true, get: function () { return time_1.clearAnimationFrame; } });\nfunction tick(fn) {\n    if (window) {\n        requestAnimationFrame(fn);\n    }\n    else {\n        // TODO need a timeline to control time\n        setTimeout(fn, 16);\n    }\n}\nexports.tick = tick;\n// 是否元素的父容器\nfunction isParent(container, shape) {\n    // 所有 shape 都是 canvas 的子元素\n    if (container.isCanvas()) {\n        return true;\n    }\n    var parent = shape.getParent();\n    var isParent = false;\n    while (parent) {\n        if (parent === container) {\n            isParent = true;\n            break;\n        }\n        parent = parent.getParent();\n    }\n    return isParent;\n}\nexports.isParent = isParent;\n//# sourceMappingURL=util.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearAnimationFrame = exports.requestAnimationFrame = exports.setExtraFunction = void 0;\nvar cache = {};\nfunction setExtraFunction(extraData) {\n    if (extraData === void 0) { extraData = {}; }\n    cache['requestAnimationFrame'] = extraData['requestAnimationFrame'];\n    cache['clearAnimationFrame'] = extraData['clearAnimationFrame'];\n}\nexports.setExtraFunction = setExtraFunction;\nfunction requestAnimationFrame(fn) {\n    if (cache['requestAnimationFrame']) {\n        return cache['requestAnimationFrame'];\n    }\n    var method = typeof window === 'object' && window.requestAnimationFrame\n        ? window.requestAnimationFrame\n        : function (f) {\n            return setTimeout(f, 16);\n        };\n    return method(fn);\n}\nexports.requestAnimationFrame = requestAnimationFrame;\nfunction clearAnimationFrame(handler) {\n    if (cache['clearAnimationFrame']) {\n        return cache['clearAnimationFrame'];\n    }\n    var method = typeof window === 'object' && window.cancelAnimationFrame ? window.cancelAnimationFrame : clearTimeout;\n    return method(handler);\n}\nexports.clearAnimationFrame = clearAnimationFrame;\n//# sourceMappingURL=time.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeView = exports.getMergedRegion = exports.getRefreshRegion = exports.refreshElement = exports.drawPath = exports.clearChanged = exports.checkChildrenRefresh = exports.checkRefresh = exports.drawChildren = exports.applyAttrsToContext = void 0;\nvar util_1 = require(\"@antv/util\");\nvar parse_1 = require(\"./parse\");\nvar arc_params_1 = require(\"./arc-params\");\nvar util_2 = require(\"./util\");\nvar ArrowUtil = require(\"../util/arrow\");\nvar SHAPE_ATTRS_MAP = {\n    fill: 'fillStyle',\n    stroke: 'strokeStyle',\n    opacity: 'globalAlpha',\n};\nfunction applyAttrsToContext(context, element) {\n    var attrs = element.attr();\n    for (var k in attrs) {\n        var v = attrs[k];\n        // 转换一下不与 canvas 兼容的属性名\n        var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\n        if (name_1 === 'matrix' && v) {\n            // 设置矩阵\n            context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\n        }\n        else if (name_1 === 'lineDash' && context.setLineDash) {\n            // 设置虚线，只支持数组形式，非数组形式不做任何操作\n            util_1.isArray(v) && context.setLineDash(v);\n        }\n        else {\n            if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {\n                // 如果存在渐变、pattern 这个开销有些大\n                // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\n                v = parse_1.parseStyle(context, element, v);\n            }\n            else if (name_1 === 'globalAlpha') {\n                // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\n                v = v * context.globalAlpha;\n            }\n            context[name_1] = v;\n        }\n    }\n}\nexports.applyAttrsToContext = applyAttrsToContext;\nfunction drawChildren(context, children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.cfg.visible) {\n            child.draw(context, region);\n        }\n        else {\n            child.skipDraw();\n        }\n    }\n}\nexports.drawChildren = drawChildren;\n// 这个地方的逻辑比较复杂，简单画了一张图：https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE\nfunction checkRefresh(canvas, children, region) {\n    var refreshElements = canvas.get('refreshElements');\n    // 先遍历需要刷新的元素，将这些元素的父元素也设置 refresh\n    util_1.each(refreshElements, function (el) {\n        if (el !== canvas) {\n            var parent_1 = el.cfg.parent;\n            while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {\n                parent_1.cfg.refresh = true;\n                parent_1 = parent_1.cfg.parent;\n            }\n        }\n    });\n    if (refreshElements[0] === canvas) {\n        setChildrenRefresh(children, region);\n    }\n    else {\n        // 检查所有子元素是否可以刷新\n        checkChildrenRefresh(children, region);\n    }\n}\nexports.checkRefresh = checkRefresh;\n// 检查所有的子元素是否应该更新\nfunction checkChildrenRefresh(children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.cfg.visible) {\n            // 先判断 hasChanged，因为它的优先级判断应该高于 refresh\n            if (child.cfg.hasChanged) {\n                // 如果节点发生了 change，则需要级联设置子元素的 refresh\n                child.cfg.refresh = true;\n                if (child.isGroup()) {\n                    setChildrenRefresh(child.cfg.children, region);\n                }\n            }\n            else if (child.cfg.refresh) {\n                // 如果当前图形/分组 refresh = true，说明其子节点存在 changed\n                if (child.isGroup()) {\n                    checkChildrenRefresh(child.cfg.children, region);\n                }\n            }\n            else {\n                // 这个分支说明此次局部刷新，所有的节点和父元素没有发生变化，仅需要检查包围盒（缓存）是否相交即可\n                var refresh = checkElementRefresh(child, region);\n                child.cfg.refresh = refresh;\n                if (refresh && child.isGroup()) {\n                    // 如果需要刷新，说明子元素也需要刷新，继续进行判定\n                    checkChildrenRefresh(child.cfg.children, region);\n                }\n            }\n        }\n    }\n}\nexports.checkChildrenRefresh = checkChildrenRefresh;\n// 由于对改变的图形放入 refreshElements 时做了优化，判定父元素 changed 时不加入\n// 那么有可能会出现 elements 都为空，所以最终 group\nfunction clearChanged(elements) {\n    for (var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        el.cfg.hasChanged = false;\n        // 级联清理\n        if (el.isGroup() && !el.destroyed) {\n            clearChanged(el.cfg.children);\n        }\n    }\n}\nexports.clearChanged = clearChanged;\n// 当某个父元素发生改变时，调用这个方法级联设置 refresh\nfunction setChildrenRefresh(children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        // let refresh = true;\n        // 获取缓存的 bbox，如果这个 bbox 还存在则说明父元素不是矩阵发生了改变\n        // const bbox = child.cfg.canvasBBox;\n        // if (bbox) {\n        //   // 如果这时候\n        //   refresh = intersectRect(bbox, region);\n        // }\n        child.cfg.refresh = true;\n        // 如果需要刷新当前节点，所有的子元素设置 refresh\n        if (child.isGroup()) {\n            setChildrenRefresh(child.get('children'), region);\n        }\n    }\n}\nfunction checkElementRefresh(shape, region) {\n    var bbox = shape.cfg.cacheCanvasBBox;\n    var isAllow = shape.cfg.isInView && bbox && util_2.intersectRect(bbox, region);\n    return isAllow;\n}\n// 绘制 path\nfunction drawPath(shape, context, attrs, arcParamsCache) {\n    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n    if (!path) {\n        return;\n    }\n    var currentPoint = [0, 0]; // 当前图形\n    var startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\n    var distance = {\n        dx: 0,\n        dy: 0,\n    };\n    context.beginPath();\n    for (var i = 0; i < path.length; i++) {\n        var params = path[i];\n        var command = params[0];\n        if (i === 0 && startArrow && startArrow.d) {\n            var tangent = shape.getStartTangent();\n            distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\n        }\n        else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\n            // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\n            var lastPath = path[i + 1];\n            if (lastPath[0] === 'Z') {\n                var tangent = shape.getEndTangent();\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n            }\n        }\n        else if (i === path.length - 1 && endArrow && endArrow.d) {\n            if (path[0] !== 'Z') {\n                var tangent = shape.getEndTangent();\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n            }\n        }\n        var dx = distance.dx, dy = distance.dy;\n        // V,H,S,T 都在前面被转换成标准形式\n        switch (command) {\n            case 'M':\n                context.moveTo(params[1] - dx, params[2] - dy);\n                startMovePoint = [params[1], params[2]];\n                break;\n            case 'L':\n                context.lineTo(params[1] - dx, params[2] - dy);\n                break;\n            case 'Q':\n                context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\n                break;\n            case 'C':\n                context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\n                break;\n            case 'A': {\n                var arcParams = void 0;\n                // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\n                if (arcParamsCache) {\n                    arcParams = arcParamsCache[i];\n                    if (!arcParams) {\n                        arcParams = arc_params_1.default(currentPoint, params);\n                        arcParamsCache[i] = arcParams;\n                    }\n                }\n                else {\n                    arcParams = arc_params_1.default(currentPoint, params);\n                }\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;\n                // 直接使用椭圆的 api\n                if (context.ellipse) {\n                    context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\n                }\n                else {\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    context.translate(cx, cy);\n                    context.rotate(xRotation);\n                    context.scale(scaleX, scaleY);\n                    context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\n                    context.scale(1 / scaleX, 1 / scaleY);\n                    context.rotate(-xRotation);\n                    context.translate(-cx, -cy);\n                }\n                break;\n            }\n            case 'Z':\n                context.closePath();\n                break;\n            default:\n                break;\n        }\n        // 有了 Z 后，当前节点从开始 M 的点开始\n        if (command === 'Z') {\n            currentPoint = startMovePoint;\n        }\n        else {\n            var len = params.length;\n            currentPoint = [params[len - 2], params[len - 1]];\n        }\n    }\n}\nexports.drawPath = drawPath;\n// 刷新图形元素(Shape 或者 Group)\nfunction refreshElement(element, changeType) {\n    var canvas = element.get('canvas');\n    // 只有存在于 canvas 上时生效\n    if (canvas) {\n        if (changeType === 'remove') {\n            // 一旦 remove，则无法在 element 上拿到包围盒\n            // destroy 后所有属性都拿不到，所以需要暂存一下\n            // 这是一段 hack 的代码\n            element._cacheCanvasBBox = element.get('cacheCanvasBBox');\n        }\n        // 防止反复刷新\n        if (!element.get('hasChanged')) {\n            // 但是始终要标记为 hasChanged，便于后面进行局部渲染\n            element.set('hasChanged', true);\n            // 本来只有局部渲染模式下，才需要记录更新的元素队列\n            // if (canvas.get('localRefresh')) {\n            //   canvas.refreshElement(element, changeType, canvas);\n            // }\n            // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\n            // 如果当前元素的父元素发生了改变，可以不放入队列，这句话大概能够提升 15% 的初次渲染性能\n            if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {\n                canvas.refreshElement(element, changeType, canvas);\n                if (canvas.get('autoDraw')) {\n                    canvas.draw();\n                }\n            }\n        }\n    }\n}\nexports.refreshElement = refreshElement;\nfunction getRefreshRegion(element) {\n    var region;\n    if (!element.destroyed) {\n        var cacheBox = element.get('cacheCanvasBBox');\n        var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\n        var bbox = element.getCanvasBBox();\n        var validBBox = bbox && !!(bbox.width && bbox.height);\n        // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\n        if (validCache && validBBox) {\n            region = util_2.mergeRegion(cacheBox, bbox);\n        }\n        else if (validCache) {\n            region = cacheBox;\n        }\n        else if (validBBox) {\n            region = bbox;\n        }\n    }\n    else {\n        // 因为元素已经销毁所以无法获取到缓存的包围盒\n        region = element['_cacheCanvasBBox'];\n    }\n    return region;\n}\nexports.getRefreshRegion = getRefreshRegion;\nfunction getMergedRegion(elements) {\n    if (!elements.length) {\n        return null;\n    }\n    var minXArr = [];\n    var minYArr = [];\n    var maxXArr = [];\n    var maxYArr = [];\n    util_1.each(elements, function (el) {\n        var region = getRefreshRegion(el);\n        if (region) {\n            minXArr.push(region.minX);\n            minYArr.push(region.minY);\n            maxXArr.push(region.maxX);\n            maxYArr.push(region.maxY);\n        }\n    });\n    return {\n        minX: Math.min.apply(null, minXArr),\n        minY: Math.min.apply(null, minYArr),\n        maxX: Math.max.apply(null, maxXArr),\n        maxY: Math.max.apply(null, maxYArr),\n    };\n}\nexports.getMergedRegion = getMergedRegion;\nfunction mergeView(region, viewRegion) {\n    if (!region || !viewRegion) {\n        return null;\n    }\n    // 不相交，则直接返回 null\n    if (!util_2.intersectRect(region, viewRegion)) {\n        return null;\n    }\n    return {\n        minX: Math.max(region.minX, viewRegion.minX),\n        minY: Math.max(region.minY, viewRegion.minY),\n        maxX: Math.min(region.maxX, viewRegion.maxX),\n        maxY: Math.min(region.maxY, viewRegion.maxY),\n    };\n}\nexports.mergeView = mergeView;\n//# sourceMappingURL=draw.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseRadius = exports.parseStyle = exports.parsePattern = exports.parseRadialGradient = exports.parseLineGradient = void 0;\nvar util_1 = require(\"./util\");\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\nfunction addStop(steps, gradient) {\n    var arr = steps.match(regexColorStop);\n    util_1.each(arr, function (item) {\n        var itemArr = item.split(':');\n        gradient.addColorStop(itemArr[0], itemArr[1]);\n    });\n}\n/**\n * 将边和填充设置的颜色转换成线性渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nfunction parseLineGradient(context, element, gradientStr) {\n    var arr = regexLG.exec(gradientStr);\n    var angle = (parseFloat(arr[1]) % 360) * (Math.PI / 180);\n    var steps = arr[2];\n    var box = element.getBBox();\n    var start;\n    var end;\n    if (angle >= 0 && angle < (1 / 2) * Math.PI) {\n        start = {\n            x: box.minX,\n            y: box.minY,\n        };\n        end = {\n            x: box.maxX,\n            y: box.maxY,\n        };\n    }\n    else if ((1 / 2) * Math.PI <= angle && angle < Math.PI) {\n        start = {\n            x: box.maxX,\n            y: box.minY,\n        };\n        end = {\n            x: box.minX,\n            y: box.maxY,\n        };\n    }\n    else if (Math.PI <= angle && angle < (3 / 2) * Math.PI) {\n        start = {\n            x: box.maxX,\n            y: box.maxY,\n        };\n        end = {\n            x: box.minX,\n            y: box.minY,\n        };\n    }\n    else {\n        start = {\n            x: box.minX,\n            y: box.maxY,\n        };\n        end = {\n            x: box.maxX,\n            y: box.minY,\n        };\n    }\n    var tanTheta = Math.tan(angle);\n    var tanTheta2 = tanTheta * tanTheta;\n    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n    var y = (tanTheta * (end.x - start.x + tanTheta * (end.y - start.y))) / (tanTheta2 + 1) + start.y;\n    var gradient = context.createLinearGradient(start.x, start.y, x, y);\n    addStop(steps, gradient);\n    return gradient;\n}\nexports.parseLineGradient = parseLineGradient;\n/**\n * 将边和填充设置的颜色转换成圆形渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nfunction parseRadialGradient(context, element, gradientStr) {\n    var arr = regexRG.exec(gradientStr);\n    var fx = parseFloat(arr[1]);\n    var fy = parseFloat(arr[2]);\n    var fr = parseFloat(arr[3]);\n    var steps = arr[4];\n    // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\n    if (fr === 0) {\n        var colors = steps.match(regexColorStop);\n        return colors[colors.length - 1].split(':')[1];\n    }\n    var box = element.getBBox();\n    var width = box.maxX - box.minX;\n    var height = box.maxY - box.minY;\n    var r = Math.sqrt(width * width + height * height) / 2;\n    var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);\n    addStop(steps, gradient);\n    return gradient;\n}\nexports.parseRadialGradient = parseRadialGradient;\n/**\n * 边和填充设置的颜色转换成 pattern\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   patternStr   生成 pattern 的字符串\n */\nfunction parsePattern(context, element, patternStr) {\n    // 在转换过程中进行了缓存\n    if (element.get('patternSource') && element.get('patternSource') === patternStr) {\n        return element.get('pattern');\n    }\n    var pattern;\n    var img;\n    var arr = regexPR.exec(patternStr);\n    var repeat = arr[1];\n    var source = arr[2];\n    // Function to be called when pattern loads\n    function onload() {\n        // Create pattern\n        pattern = context.createPattern(img, repeat);\n        element.set('pattern', pattern); // be a cache\n        element.set('patternSource', patternStr);\n    }\n    switch (repeat) {\n        case 'a':\n            repeat = 'repeat';\n            break;\n        case 'x':\n            repeat = 'repeat-x';\n            break;\n        case 'y':\n            repeat = 'repeat-y';\n            break;\n        case 'n':\n            repeat = 'no-repeat';\n            break;\n        default:\n            repeat = 'no-repeat';\n    }\n    img = new Image();\n    // If source URL is not a data URL\n    if (!source.match(/^data:/i)) {\n        // Set crossOrigin for this image\n        img.crossOrigin = 'Anonymous';\n    }\n    img.src = source;\n    if (img.complete) {\n        onload();\n    }\n    else {\n        img.onload = onload;\n        // Fix onload() bug in IE9\n        img.src = img.src;\n    }\n    return pattern;\n}\nexports.parsePattern = parsePattern;\nfunction parseStyle(context, element, color) {\n    if (util_1.isString(color)) {\n        if (color[1] === '(' || color[2] === '(') {\n            if (color[0] === 'l') {\n                // regexLG.test(color)\n                return parseLineGradient(context, element, color);\n            }\n            if (color[0] === 'r') {\n                // regexRG.test(color)\n                return parseRadialGradient(context, element, color);\n            }\n            if (color[0] === 'p') {\n                // regexPR.test(color)\n                return parsePattern(context, element, color);\n            }\n        }\n        return color;\n    }\n}\nexports.parseStyle = parseStyle;\nfunction parseRadius(radius) {\n    var r1 = 0;\n    var r2 = 0;\n    var r3 = 0;\n    var r4 = 0;\n    if (util_1.isArray(radius)) {\n        if (radius.length === 1) {\n            r1 = r2 = r3 = r4 = radius[0];\n        }\n        else if (radius.length === 2) {\n            r1 = r3 = radius[0];\n            r2 = r4 = radius[1];\n        }\n        else if (radius.length === 3) {\n            r1 = radius[0];\n            r2 = r4 = radius[1];\n            r3 = radius[2];\n        }\n        else {\n            r1 = radius[0];\n            r2 = radius[1];\n            r3 = radius[2];\n            r4 = radius[3];\n        }\n    }\n    else {\n        r1 = r2 = r3 = r4 = radius;\n    }\n    return [r1, r2, r3, r4];\n}\nexports.parseRadius = parseRadius;\n//# sourceMappingURL=parse.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\n// 向量长度\nfunction vMag(v) {\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n// u.v/|u||v|，计算夹角的余弦值\nfunction vRatio(u, v) {\n    // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\n    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\n}\n// 向量角度\nfunction vAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\nfunction getArcParams(startPoint, params) {\n    var rx = params[1];\n    var ry = params[2];\n    var xRotation = util_1.mod(util_1.toRadian(params[3]), Math.PI * 2);\n    var arcFlag = params[4];\n    var sweepFlag = params[5];\n    // 弧形起点坐标\n    var x1 = startPoint[0];\n    var y1 = startPoint[1];\n    // 弧形终点坐标\n    var x2 = params[6];\n    var y2 = params[7];\n    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;\n    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;\n    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\n    if (arcFlag === sweepFlag) {\n        f *= -1;\n    }\n    if (isNaN(f)) {\n        f = 0;\n    }\n    // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\n    var cxp = ry ? (f * rx * yp) / ry : 0;\n    var cyp = rx ? (f * -ry * xp) / rx : 0;\n    // 椭圆圆心坐标\n    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\n    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\n    // 起始点的单位向量\n    var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n    // 终止点的单位向量\n    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n    // 计算起始点和圆心的连线，与 x 轴正方向的夹角\n    var theta = vAngle([1, 0], u);\n    // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\n    var dTheta = vAngle(u, v);\n    if (vRatio(u, v) <= -1) {\n        dTheta = Math.PI;\n    }\n    if (vRatio(u, v) >= 1) {\n        dTheta = 0;\n    }\n    if (sweepFlag === 0 && dTheta > 0) {\n        dTheta = dTheta - 2 * Math.PI;\n    }\n    if (sweepFlag === 1 && dTheta < 0) {\n        dTheta = dTheta + 2 * Math.PI;\n    }\n    return {\n        cx: cx,\n        cy: cy,\n        // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\n        rx: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : rx,\n        ry: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : ry,\n        startAngle: theta,\n        endAngle: theta + dTheta,\n        xRotation: xRotation,\n        arcFlag: arcFlag,\n        sweepFlag: sweepFlag,\n    };\n}\nexports.default = getArcParams;\n//# sourceMappingURL=arc-params.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addEndArrow = exports.addStartArrow = exports.getShortenOffset = void 0;\nvar tslib_1 = require(\"tslib\");\nvar shape_1 = require(\"../shape\");\nvar sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;\nfunction _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {\n    var stroke = attrs.stroke, lineWidth = attrs.lineWidth;\n    var x = x1 - x2;\n    var y = y1 - y2;\n    var rad = atan2(y, x);\n    var arrowShape = new shape_1.Path({\n        type: 'path',\n        canvas: shape.get('canvas'),\n        isArrowShape: true,\n        attrs: {\n            // 默认箭头的边长为 10，夹角为 60 度\n            path: \"M\" + 10 * cos(PI / 6) + \",\" + 10 * sin(PI / 6) + \" L0,0 L\" + 10 * cos(PI / 6) + \",-\" + 10 * sin(PI / 6),\n            // 使用 shape stroke 值\n            stroke: stroke,\n            lineWidth: lineWidth,\n        },\n    });\n    arrowShape.translate(x2, y2);\n    arrowShape.rotateAtPoint(x2, y2, rad);\n    shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);\n}\n/**\n * 箭头 path 的设置要求\n * 1. 箭头顶点坐标需要为 (0, 0)\n * 2. 箭头夹角的中心分割线需要与 X 轴正方向对齐\n */\nfunction _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {\n    var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;\n    var arrowAttrs = isStart ? startArrow : endArrow;\n    var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = tslib_1.__rest(arrowAttrs, [\"d\", \"fill\", \"stroke\", \"lineWidth\"]);\n    var x = x1 - x2;\n    var y = y1 - y2;\n    var rad = atan2(y, x);\n    if (d) {\n        x2 = x2 - cos(rad) * d;\n        y2 = y2 - sin(rad) * d;\n    }\n    var arrowShape = new shape_1.Path({\n        type: 'path',\n        canvas: shape.get('canvas'),\n        isArrowShape: true,\n        attrs: tslib_1.__assign(tslib_1.__assign({}, restAttrs), { \n            // 支持单独设置箭头的 stroke 和 lineWidth，若为空则使用 shape 的值\n            stroke: arrowStroke || stroke, lineWidth: arrowLineWidth || lineWidth, \n            // 箭头是否填充需要手动设置，不会继承自 shape 的值\n            fill: arrowFill }),\n    });\n    arrowShape.translate(x2, y2);\n    arrowShape.rotateAtPoint(x2, y2, rad);\n    shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);\n}\n/**\n * 如果自定义箭头并且有 d 需要做偏移，如果直接画，线条会超出箭头尖端，因此需要根据箭头偏移 d, 返回线需要缩短的距离\n * |----------------\n * |<|--------------\n * |\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 箭头作用点 x\n * @param {number} y2 箭头作用点 y\n * @param {number} d  箭头沿线条方向的偏移距离\n * @return {{dx: number, dy: number}} 返回线条偏移距离\n */\nfunction getShortenOffset(x1, y1, x2, y2, d) {\n    var rad = atan2(y2 - y1, x2 - x1);\n    return {\n        dx: cos(rad) * d,\n        dy: sin(rad) * d,\n    };\n}\nexports.getShortenOffset = getShortenOffset;\n/**\n * 绘制起始箭头\n * @param {IShape} shape 图形\n * @param {ShapeAttrs} attrs shape 的绘图属性\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 箭头作用点 x\n * @param {number} y2 箭头作用点 y\n */\nfunction addStartArrow(shape, attrs, x1, y1, x2, y2) {\n    if (typeof attrs.startArrow === 'object') {\n        _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);\n    }\n    else if (attrs.startArrow) {\n        _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);\n    }\n    else {\n        shape.set('startArrowShape', null);\n    }\n}\nexports.addStartArrow = addStartArrow;\n/**\n * 绘制结束箭头\n * @param {IShape} shape 图形\n * @param {ShapeAttrs} attrs shape 的绘图属性\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 箭头作用点 x\n * @param {number} y2 箭头作用点 y\n */\nfunction addEndArrow(shape, attrs, x1, y1, x2, y2) {\n    if (typeof attrs.endArrow === 'object') {\n        _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);\n    }\n    else if (attrs.endArrow) {\n        _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);\n    }\n    else {\n        shape.set('startArrowShape', null);\n    }\n}\nexports.addEndArrow = addEndArrow;\n//# sourceMappingURL=arrow.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar g_base_1 = require(\"@antv/g-base\");\nvar Shape = require(\"./shape\");\nvar draw_1 = require(\"./util/draw\");\nvar util_1 = require(\"@antv/util\");\nvar util_2 = require(\"./util/util\");\nvar Group = /** @class */ (function (_super) {\n    tslib_1.__extends(Group, _super);\n    function Group() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Group.prototype.onCanvasChange = function (changeType) {\n        draw_1.refreshElement(this, changeType);\n    };\n    Group.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Group.prototype.getGroupBase = function () {\n        return Group;\n    };\n    // 同 shape 中的方法重复了\n    Group.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            // 将 clip 的属性挂载到 context 上\n            draw_1.applyAttrsToContext(context, clip);\n            // 绘制 clip 路径\n            clip.createPath(context);\n            context.restore();\n            // 裁剪\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    // 这个方法以前直接使用的 getCanvasBBox，由于 group 上没有缓存，所以每次重新计算，导致性能开销比较大\n    // 大概能够节省全局渲染 15-20% 的性能，如果不在这里加缓存优化后 10W 个节点无法达到 5-6 ms，大概能够 30-40ms\n    Group.prototype.cacheCanvasBBox = function () {\n        var children = this.cfg.children;\n        var xArr = [];\n        var yArr = [];\n        util_1.each(children, function (child) {\n            var bbox = child.cfg.cacheCanvasBBox;\n            // isInview 的判定是一旦图形或者分组渲染就要计算是否在视图内，\n            // 这个判定 10W 个图形下差不多能够节省 5-6 ms 的开销\n            if (bbox && child.cfg.isInView) {\n                xArr.push(bbox.minX, bbox.maxX);\n                yArr.push(bbox.minY, bbox.maxY);\n            }\n        });\n        var bbox = null;\n        if (xArr.length) {\n            var minX = Math.min.apply(null, xArr);\n            var maxX = Math.max.apply(null, xArr);\n            var minY = Math.min.apply(null, yArr);\n            var maxY = Math.max.apply(null, yArr);\n            bbox = {\n                minX: minX,\n                minY: minY,\n                x: minX,\n                y: minY,\n                maxX: maxX,\n                maxY: maxY,\n                width: maxX - minX,\n                height: maxY - minY,\n            };\n            var canvas = this.cfg.canvas;\n            if (canvas) {\n                var viewRange = canvas.getViewRange();\n                // 如果这个地方判定 isInView == false 设置 bbox 为 false 的话，拾取的性能会更高\n                // 但是目前 10W 图形的拾取在 2-5ms 内，这个优化意义不大，可以后期观察再看\n                this.set('isInView', util_2.intersectRect(bbox, viewRange));\n            }\n        }\n        else {\n            this.set('isInView', false);\n        }\n        this.set('cacheCanvasBBox', bbox);\n    };\n    Group.prototype.draw = function (context, region) {\n        var children = this.cfg.children;\n        var allowDraw = region ? this.cfg.refresh : true; // 局部刷新需要判定\n        // 这个地方需要判定，在 G6 的场景每个 group 都有 transform 的场景下性能会开销非常大\n        // 通过 refresh 的判定，可以不刷新没有发生过变化的分组，不在视窗内的分组等等\n        // 如果想进一步提升局部渲染性能，可以进一步优化 refresh 的判定，依然有潜力\n        if (children.length && allowDraw) {\n            context.save();\n            // group 上的矩阵和属性也会应用到上下文上\n            // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n            draw_1.applyAttrsToContext(context, this);\n            this._applyClip(context, this.getClip());\n            draw_1.drawChildren(context, children, region);\n            context.restore();\n            this.cacheCanvasBBox();\n        }\n        // 这里的成本比较大，如果不绘制则不再\n        // this.set('cacheCanvasBBox', this.getCanvasBBox());\n        this.cfg.refresh = null;\n        // 绘制后，消除更新标记\n        this.set('hasChanged', false);\n    };\n    // 绘制时被跳过，一般发生在分组隐藏时\n    Group.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('hasChanged', false);\n    };\n    return Group;\n}(g_base_1.AbstractGroup));\nexports.default = Group;\n//# sourceMappingURL=group.js.map","\n/**\n * @fileoverview 圆\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util/util\");\nvar Circle = /** @class */ (function (_super) {\n    tslib_1.__extends(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, r: 0 });\n    };\n    Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var r = attrs.r;\n        var halfLineWidth = lineWidth / 2;\n        var absDistance = util_1.distance(cx, cy, x, y);\n        // 直接用距离，如果同时存在边和填充时，可以减少两次计算\n        if (isFill && isStroke) {\n            return absDistance <= r + halfLineWidth;\n        }\n        if (isFill) {\n            return absDistance <= r;\n        }\n        if (isStroke) {\n            return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n        }\n        return false;\n    };\n    Circle.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var r = attrs.r;\n        context.beginPath();\n        context.arc(cx, cy, r, 0, Math.PI * 2, false);\n        context.closePath();\n    };\n    return Circle;\n}(base_1.default));\nexports.default = Circle;\n//# sourceMappingURL=circle.js.map","\n/**\n * @fileoverview 椭圆\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\n// 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n    return squareX / (rx * rx) + squareY / (ry * ry);\n}\nvar Ellipse = /** @class */ (function (_super) {\n    tslib_1.__extends(Ellipse, _super);\n    function Ellipse() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Ellipse.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });\n    };\n    Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var halfLineWith = lineWidth / 2;\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var rx = attrs.rx, ry = attrs.ry;\n        var squareX = (x - cx) * (x - cx);\n        var squareY = (y - cy) * (y - cy);\n        // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n        if (isFill && isStroke) {\n            return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n        }\n        if (isFill) {\n            return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n        }\n        if (isStroke) {\n            return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 &&\n                ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1);\n        }\n        return false;\n    };\n    Ellipse.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var rx = attrs.rx;\n        var ry = attrs.ry;\n        context.beginPath();\n        // 兼容逻辑\n        if (context.ellipse) {\n            context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\n        }\n        else {\n            // 如果不支持，则使用圆来绘制，进行变形\n            var r = rx > ry ? rx : ry;\n            var scaleX = rx > ry ? 1 : rx / ry;\n            var scaleY = rx > ry ? ry / rx : 1;\n            context.save();\n            context.translate(cx, cy);\n            context.scale(scaleX, scaleY);\n            context.arc(0, 0, r, 0, Math.PI * 2);\n            context.restore();\n            context.closePath();\n        }\n    };\n    return Ellipse;\n}(base_1.default));\nexports.default = Ellipse;\n//# sourceMappingURL=ellipse.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setMiniCanvas = void 0;\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util/util\");\nfunction isCanvas(dom) {\n    return dom instanceof HTMLElement && util_1.isString(dom.nodeName) && dom.nodeName.toUpperCase() === 'CANVAS';\n}\nvar miniCanvas = null;\nfunction setMiniCanvas(canvas) {\n    miniCanvas = canvas;\n}\nexports.setMiniCanvas = setMiniCanvas;\nvar ImageShape = /** @class */ (function (_super) {\n    tslib_1.__extends(ImageShape, _super);\n    function ImageShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImageShape.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });\n    };\n    ImageShape.prototype.initAttrs = function (attrs) {\n        this._setImage(attrs.img);\n    };\n    // image 不计算 stroke\n    ImageShape.prototype.isStroke = function () {\n        return false;\n    };\n    // 仅仅使用包围盒检测来进行拾取\n    // 所以不需要复写 isInStrokeOrPath 的方法\n    ImageShape.prototype.isOnlyHitBox = function () {\n        return true;\n    };\n    ImageShape.prototype._afterLoading = function () {\n        if (this.get('toDraw') === true) {\n            var canvas = this.get('canvas');\n            if (canvas) {\n                // 这段应该改成局部渲染\n                canvas.draw();\n            }\n            else {\n                // 这种方式如果发生遮挡会出现问题\n                this.createPath(this.get('context'));\n            }\n        }\n    };\n    ImageShape.prototype._setImage = function (img) {\n        var _this = this;\n        var attrs = this.attrs;\n        console.log('xxxx', img, miniCanvas.isMiniNative(), miniCanvas, miniCanvas.isMini());\n        // 1.0 小程序canvas下只能用string绘制\n        if (miniCanvas.isMini() && !miniCanvas.isMiniNative()) {\n            this.attr('img', img);\n            return;\n        }\n        // 以下兼容2.0 小程序canvas\n        if (util_1.isString(img)) {\n            var image_1 = null;\n            if (miniCanvas.isMiniNative()) {\n                image_1 = miniCanvas.get('extra').createImage();\n            }\n            else {\n                image_1 = new Image();\n            }\n            image_1.onload = function () {\n                // 图片未加载完，则已经被销毁\n                if (_this.destroyed) {\n                    return false;\n                }\n                // 缓存原始地址，可以做对比，防止重复加载图片\n                // 如果考虑到在加载过程中可能替换 img 属性，则情况更加复杂\n                // this.set('imgSrc', img);\n                // 这里会循环调用 _setImage 方法，但不会再走这个分支\n                _this.attr('img', image_1);\n                _this.set('loading', false);\n                _this._afterLoading();\n                var callback = _this.get('callback');\n                if (callback) {\n                    callback.call(_this);\n                }\n            };\n            // 设置跨域\n            image_1.crossOrigin = 'Anonymous';\n            image_1.src = img;\n            // loading 过程中不绘制\n            this.set('loading', true);\n        }\n        else if (miniCanvas.isMiniNative() || img instanceof Image) {\n            if (!attrs.width) {\n                attrs.width = img.width;\n            }\n            if (!attrs.height) {\n                attrs.height = img.height;\n            }\n        }\n        else if (isCanvas(img)) {\n            // 如果设置了 canvas 对象\n            if (!attrs.width) {\n                attrs.width = Number(img.getAttribute('width'));\n            }\n            if (!attrs.height) {\n                attrs.height, Number(img.getAttribute('height'));\n            }\n        }\n    };\n    ImageShape.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        // 如果加载的已经是当前图片，则不再处理\n        if (name === 'img') {\n            // 可以加缓冲，&& this.get('imgSrc') !== value\n            this._setImage(value);\n        }\n    };\n    ImageShape.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var img = attrs.img, x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;\n        // 正在加载则不绘制\n        if (this.get('loading')) {\n            this.set('toDraw', true); // 加载完成后绘制\n            this.set('context', context);\n            return;\n        }\n        if (miniCanvas.isMini()) {\n            context.drawImage(img, x, y, width, height);\n            return;\n        }\n        if (img instanceof Image || isCanvas(img)) {\n            if (!util_1.isNil(sx) && !util_1.isNil(sy) && !util_1.isNil(swidth) && !util_1.isNil(sheight)) {\n                context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);\n            }\n            else {\n                context.drawImage(img, x, y, width, height);\n            }\n        }\n    };\n    return ImageShape;\n}(base_1.default));\nexports.default = ImageShape;\n//# sourceMappingURL=image.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/**\n * @fileoverview 圆\n * @author dxq613@gmail.com\n */\nvar g_math_1 = require(\"@antv/g-math\");\nvar base_1 = require(\"./base\");\nvar line_1 = require(\"../util/in-stroke/line\");\nvar ArrowUtil = require(\"../util/arrow\");\nvar Line = /** @class */ (function (_super) {\n    tslib_1.__extends(Line, _super);\n    function Line() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Line.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });\n    };\n    Line.prototype.initAttrs = function (attrs) {\n        this.setArrow();\n    };\n    // 更新属性时，检测是否更改了箭头\n    Line.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n        this.setArrow();\n    };\n    Line.prototype.setArrow = function () {\n        var attrs = this.attr();\n        var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n        if (startArrow) {\n            ArrowUtil.addStartArrow(this, attrs, x2, y2, x1, y1);\n        }\n        if (endArrow) {\n            ArrowUtil.addEndArrow(this, attrs, x1, y1, x2, y2);\n        }\n    };\n    Line.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        if (!isStroke || !lineWidth) {\n            return false;\n        }\n        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\n        return line_1.default(x1, y1, x2, y2, lineWidth, x, y);\n    };\n    Line.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n        var startArrowDistance = {\n            dx: 0,\n            dy: 0,\n        };\n        var endArrowDistance = {\n            dx: 0,\n            dy: 0,\n        };\n        if (startArrow && startArrow.d) {\n            startArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);\n        }\n        if (endArrow && endArrow.d) {\n            endArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);\n        }\n        context.beginPath();\n        // 如果自定义箭头，线条相应缩进\n        context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);\n        context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);\n    };\n    Line.prototype.afterDrawPath = function (context) {\n        var startArrowShape = this.get('startArrowShape');\n        var endArrowShape = this.get('endArrowShape');\n        if (startArrowShape) {\n            startArrowShape.draw(context);\n        }\n        if (endArrowShape) {\n            endArrowShape.draw(context);\n        }\n    };\n    /**\n     * Get length of line\n     * @return {number} length\n     */\n    Line.prototype.getTotalLength = function () {\n        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\n        return g_math_1.Line.length(x1, y1, x2, y2);\n    };\n    /**\n     * Get point according to ratio\n     * @param {number} ratio\n     * @return {Point} point\n     */\n    Line.prototype.getPoint = function (ratio) {\n        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\n        return g_math_1.Line.pointAt(x1, y1, x2, y2, ratio);\n    };\n    return Line;\n}(base_1.default));\nexports.default = Line;\n//# sourceMappingURL=line.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar g_math_1 = require(\"@antv/g-math\");\nfunction inLine(x1, y1, x2, y2, lineWidth, x, y) {\n    var minX = Math.min(x1, x2);\n    var maxX = Math.max(x1, x2);\n    var minY = Math.min(y1, y2);\n    var maxY = Math.max(y1, y2);\n    var halfWidth = lineWidth / 2;\n    // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n    // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {\n        return false;\n    }\n    // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n    return g_math_1.Line.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\nexports.default = inLine;\n//# sourceMappingURL=line.js.map","\n/**\n * @fileoverview Marker\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar path_util_1 = require(\"@antv/path-util\");\nvar base_1 = require(\"./base\");\nvar util_2 = require(\"../util/util\");\nvar draw_1 = require(\"../util/draw\");\nvar Symbols = {\n    // 圆\n    circle: function (x, y, r) {\n        return [\n            ['M', x - r, y],\n            ['A', r, r, 0, 1, 0, x + r, y],\n            ['A', r, r, 0, 1, 0, x - r, y],\n        ];\n    },\n    // 正方形\n    square: function (x, y, r) {\n        return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];\n    },\n    // 菱形\n    diamond: function (x, y, r) {\n        return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];\n    },\n    // 三角形\n    triangle: function (x, y, r) {\n        var diffY = r * Math.sin((1 / 3) * Math.PI);\n        return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['Z']];\n    },\n    // 倒三角形\n    'triangle-down': function (x, y, r) {\n        var diffY = r * Math.sin((1 / 3) * Math.PI);\n        return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];\n    },\n};\nvar Marker = /** @class */ (function (_super) {\n    tslib_1.__extends(Marker, _super);\n    function Marker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Marker.prototype.initAttrs = function (attrs) {\n        this._resetParamsCache();\n    };\n    // 重置绘制 path 存储的缓存\n    Marker.prototype._resetParamsCache = function () {\n        // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n        // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n        this.set('paramsCache', {}); // 清理缓存\n    };\n    // 更新属性时，检测是否更改了 path\n    Marker.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (['symbol', 'x', 'y', 'r', 'radius'].indexOf(name) !== -1) {\n            // path 相关属性更改时，清理缓存\n            this._resetParamsCache();\n        }\n    };\n    // 仅仅使用包围盒检测来进行拾取\n    // 所以不需要复写 isInStrokeOrPath 的方法\n    Marker.prototype.isOnlyHitBox = function () {\n        return true;\n    };\n    Marker.prototype._getR = function (attrs) {\n        // 兼容 r 和 radius 两种写法，推荐使用 r\n        return util_1.isNil(attrs.r) ? attrs.radius : attrs.r;\n    };\n    Marker.prototype._getPath = function () {\n        var attrs = this.attr();\n        var x = attrs.x, y = attrs.y;\n        var symbol = attrs.symbol || 'circle';\n        var r = this._getR(attrs);\n        var method;\n        var path;\n        if (util_2.isFunction(symbol)) {\n            method = symbol;\n            path = method(x, y, r);\n            // 将 path 转成绝对路径\n            path = path_util_1.path2Absolute(path);\n        }\n        else {\n            // 内置 symbol 的 path 都是绝对路径，直接绘制即可，不需要对 path 进行特殊处理\n            method = Marker.Symbols[symbol];\n            if (!method) {\n                console.warn(symbol + \" marker is not supported.\");\n                return null;\n            }\n            path = method(x, y, r);\n        }\n        return path;\n    };\n    Marker.prototype.createPath = function (context) {\n        var path = this._getPath();\n        var paramsCache = this.get('paramsCache');\n        draw_1.drawPath(this, context, { path: path }, paramsCache);\n    };\n    Marker.Symbols = Symbols;\n    return Marker;\n}(base_1.default));\nexports.default = Marker;\n//# sourceMappingURL=marker.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar g_math_1 = require(\"@antv/g-math\");\nvar util_1 = require(\"@antv/util\");\nvar base_1 = require(\"./base\");\nvar path_util_1 = require(\"@antv/path-util\");\nvar draw_1 = require(\"../util/draw\");\nvar polygon_1 = require(\"../util/in-path/polygon\");\nvar path_1 = require(\"../util/path\");\nvar ArrowUtil = require(\"../util/arrow\");\n// 是否在多个多边形内部\nfunction isInPolygons(polygons, x, y) {\n    var isHit = false;\n    for (var i = 0; i < polygons.length; i++) {\n        var points = polygons[i];\n        isHit = polygon_1.default(points, x, y);\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\nvar Path = /** @class */ (function (_super) {\n    tslib_1.__extends(Path, _super);\n    function Path() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Path.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { startArrow: false, endArrow: false });\n    };\n    Path.prototype.initAttrs = function (attrs) {\n        this._setPathArr(attrs.path);\n        this.setArrow();\n    };\n    // 更新属性时，检测是否更改了 path\n    Path.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name === 'path') {\n            this._setPathArr(value);\n        }\n        // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n        this.setArrow();\n    };\n    // 将 path 转换成绝对路径\n    Path.prototype._setPathArr = function (path) {\n        // 转换 path 的格式\n        this.attrs.path = path_util_1.path2Absolute(path);\n        var hasArc = path_1.default.hasArc(path);\n        // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n        // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n        this.set('hasArc', hasArc);\n        this.set('paramsCache', {}); // 清理缓存\n        this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n        this.set('curve', null);\n        this.set('tCache', null);\n        this.set('totalLength', null);\n    };\n    Path.prototype.getSegments = function () {\n        var segments = this.get('segements');\n        if (!segments) {\n            segments = path_util_1.path2Segments(this.attr('path'));\n            this.set('segments', segments);\n        }\n        return segments;\n    };\n    Path.prototype.setArrow = function () {\n        var attrs = this.attr();\n        var startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n        if (startArrow) {\n            var tangent = this.getStartTangent();\n            ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n        }\n        if (endArrow) {\n            var tangent = this.getEndTangent();\n            ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n        }\n    };\n    Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var segments = this.getSegments();\n        var hasArc = this.get('hasArc');\n        var isHit = false;\n        if (isStroke) {\n            var length_1 = this.getTotalLength();\n            isHit = path_1.default.isPointInStroke(segments, lineWidth, x, y, length_1);\n        }\n        if (!isHit && isFill) {\n            // TODO 处理hasArc的场景\n            var path = this.attr('path');\n            var extractResutl = path_1.default.extractPolygons(path);\n            // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n            isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n        }\n        return isHit;\n    };\n    Path.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n        draw_1.drawPath(this, context, attrs, paramsCache);\n    };\n    Path.prototype.afterDrawPath = function (context) {\n        var startArrowShape = this.get('startArrowShape');\n        var endArrowShape = this.get('endArrowShape');\n        if (startArrowShape) {\n            startArrowShape.draw(context);\n        }\n        if (endArrowShape) {\n            endArrowShape.draw(context);\n        }\n    };\n    /**\n     * Get total length of path\n     * @return {number} length\n     */\n    Path.prototype.getTotalLength = function () {\n        var totalLength = this.get('totalLength');\n        if (!util_1.isNil(totalLength)) {\n            return totalLength;\n        }\n        this._calculateCurve();\n        this._setTcache();\n        return this.get('totalLength');\n    };\n    /**\n     * Get point according to ratio\n     * @param {number} ratio\n     * @return {Point} point\n     */\n    Path.prototype.getPoint = function (ratio) {\n        var tCache = this.get('tCache');\n        if (!tCache) {\n            this._calculateCurve();\n            this._setTcache();\n            tCache = this.get('tCache');\n        }\n        var subt;\n        var index;\n        var curve = this.get('curve');\n        if (!tCache || tCache.length === 0) {\n            if (curve) {\n                return {\n                    x: curve[0][1],\n                    y: curve[0][2],\n                };\n            }\n            return null;\n        }\n        util_1.each(tCache, function (v, i) {\n            if (ratio >= v[0] && ratio <= v[1]) {\n                subt = (ratio - v[0]) / (v[1] - v[0]);\n                index = i;\n            }\n        });\n        var seg = curve[index];\n        if (util_1.isNil(seg) || util_1.isNil(index)) {\n            return null;\n        }\n        var l = seg.length;\n        var nextSeg = curve[index + 1];\n        return g_math_1.Cubic.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\n    };\n    Path.prototype._calculateCurve = function () {\n        var path = this.attr().path;\n        this.set('curve', path_1.default.pathToCurve(path));\n    };\n    Path.prototype._setTcache = function () {\n        var totalLength = 0;\n        var tempLength = 0;\n        // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n        var tCache = [];\n        var segmentT;\n        var segmentL;\n        var segmentN;\n        var l;\n        var curve = this.get('curve');\n        if (!curve) {\n            return;\n        }\n        util_1.each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                totalLength +=\n                    g_math_1.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n            }\n        });\n        this.set('totalLength', totalLength);\n        if (totalLength === 0) {\n            this.set('tCache', []);\n            return;\n        }\n        util_1.each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                segmentT = [];\n                segmentT[0] = tempLength / totalLength;\n                segmentL = g_math_1.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n                // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n                tempLength += segmentL || 0;\n                segmentT[1] = tempLength / totalLength;\n                tCache.push(segmentT);\n            }\n        });\n        this.set('tCache', tCache);\n    };\n    /**\n     * Get start tangent vector\n     * @return {Array}\n     */\n    Path.prototype.getStartTangent = function () {\n        var segments = this.getSegments();\n        var result;\n        if (segments.length > 1) {\n            var startPoint = segments[0].currentPoint;\n            var endPoint = segments[1].currentPoint;\n            var tangent = segments[1].startTangent;\n            result = [];\n            if (tangent) {\n                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n                result.push([startPoint[0], startPoint[1]]);\n            }\n            else {\n                result.push([endPoint[0], endPoint[1]]);\n                result.push([startPoint[0], startPoint[1]]);\n            }\n        }\n        return result;\n    };\n    /**\n     * Get end tangent vector\n     * @return {Array}\n     */\n    Path.prototype.getEndTangent = function () {\n        var segments = this.getSegments();\n        var length = segments.length;\n        var result;\n        if (length > 1) {\n            var startPoint = segments[length - 2].currentPoint;\n            var endPoint = segments[length - 1].currentPoint;\n            var tangent = segments[length - 1].endTangent;\n            result = [];\n            if (tangent) {\n                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n                result.push([endPoint[0], endPoint[1]]);\n            }\n            else {\n                result.push([startPoint[0], startPoint[1]]);\n                result.push([endPoint[0], endPoint[1]]);\n            }\n        }\n        return result;\n    };\n    return Path;\n}(base_1.default));\nexports.default = Path;\n//# sourceMappingURL=path.js.map","\n/**\n * @fileoverview 判断点是否在多边形内\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nvar tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x) {\n    if (Math.abs(x) < tolerance) {\n        return 0;\n    }\n    return x < 0 ? -1 : 1;\n}\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n        Math.min(p1[0], p2[0]) <= q[0] &&\n        q[0] <= Math.max(p1[0], p2[0]) &&\n        Math.min(p1[1], p2[1]) <= q[1] &&\n        q[1] <= Math.max(p1[1], p2[1])) {\n        return true;\n    }\n    return false;\n}\n// 判断点P在多边形内-射线法\nfunction isInPolygon(points, x, y) {\n    var isHit = false;\n    var n = points.length;\n    if (n <= 2) {\n        // svg 中点小于 3 个时，不显示，也无法被拾取\n        return false;\n    }\n    for (var i = 0; i < n; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % n];\n        if (onSegment(p1, p2, [x, y])) {\n            // 点在多边形一条边上\n            return true;\n        }\n        // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n        // 后一个判断被测点 在 射线与边交点 的左边\n        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {\n            isHit = !isHit;\n        }\n    }\n    return isHit;\n}\nexports.default = isInPolygon;\n//# sourceMappingURL=polygon.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nvar g_base_1 = require(\"@antv/g-base\");\nvar g_math_1 = require(\"@antv/g-math\");\nvar g_math_2 = require(\"@antv/g-math\");\nvar matrix_util_1 = require(\"@antv/matrix-util\");\nvar vec3 = require(\"gl-matrix/vec3\");\nvar util_1 = require(\"./util\");\nvar line_1 = require(\"./in-stroke/line\");\nvar arc_1 = require(\"./in-stroke/arc\");\nvar transform = matrix_util_1.ext.transform;\nfunction hasArc(path) {\n    var hasArc = false;\n    var count = path.length;\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n            hasArc = true;\n            break;\n        }\n    }\n    return hasArc;\n}\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n    var isHit = false;\n    var halfWidth = lineWidth / 2;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;\n        // 如果在前面已经生成过包围盒，直接按照包围盒计算\n        if (box && !util_1.inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n            continue;\n        }\n        switch (segment.command) {\n            // L 和 Z 都是直线， M 不进行拾取\n            case 'L':\n            case 'Z':\n                isHit = line_1.default(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n                break;\n            case 'Q':\n                var qDistance = g_math_1.Quad.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n                isHit = qDistance <= lineWidth / 2;\n                break;\n            case 'C':\n                var cDistance = g_math_2.Cubic.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n                params[2], params[3], params[4], params[5], params[6], x, y, length);\n                isHit = cDistance <= lineWidth / 2;\n                break;\n            case 'A':\n                // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n                var arcParams = segment.arcParams;\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;\n                var p = [x, y, 1];\n                var r = rx > ry ? rx : ry;\n                var scaleX = rx > ry ? 1 : rx / ry;\n                var scaleY = rx > ry ? ry / rx : 1;\n                var m = transform(null, [\n                    ['t', -cx, -cy],\n                    ['r', -xRotation],\n                    ['s', 1 / scaleX, 1 / scaleY],\n                ]);\n                vec3.transformMat3(p, p, m);\n                isHit = arc_1.default(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n                break;\n            default:\n                break;\n        }\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n    var count = path.length;\n    var polygons = [];\n    var polylines = [];\n    var points = []; // 防止第一个命令不是 'M'\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'M') {\n            // 遇到 'M' 判定是否是新数组，新数组中没有点\n            if (points.length) {\n                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n                polylines.push(points);\n                points = []; // 创建新的点\n            }\n            points.push([params[1], params[2]]);\n        }\n        else if (cmd === 'Z') {\n            if (points.length) {\n                // 存在点\n                polygons.push(points);\n                points = []; // 开始新的点集合\n            }\n            // 如果不存在点，同时 'Z'，则说明是错误，不处理\n        }\n        else {\n            points.push([params[1], params[2]]);\n        }\n    }\n    // 说明 points 未放入 polygons 或者 polyline\n    // 仅当只有一个 M，没有 Z 时会发生这种情况\n    if (points.length > 0) {\n        polylines.push(points);\n    }\n    return {\n        polygons: polygons,\n        polylines: polylines,\n    };\n}\nexports.default = tslib_1.__assign({ hasArc: hasArc,\n    extractPolygons: extractPolygons,\n    isPointInStroke: isPointInStroke }, g_base_1.PathUtil);\n//# sourceMappingURL=path.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nfunction arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {\n    var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\n    if (angle < startAngle || angle > endAngle) {\n        return false;\n    }\n    var point = {\n        x: cx + r * Math.cos(angle),\n        y: cy + r * Math.sin(angle),\n    };\n    return util_1.distance(point.x, point.y, x, y) <= lineWidth / 2;\n}\nexports.default = arc;\n//# sourceMappingURL=arc.js.map","\n/**\n * @fileoverview 多边形\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar polyline_1 = require(\"../util/in-stroke/polyline\");\nvar polygon_1 = require(\"../util/in-path/polygon\");\nvar Polygon = /** @class */ (function (_super) {\n    tslib_1.__extends(Polygon, _super);\n    function Polygon() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Polygon.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var points = this.attr().points;\n        var isHit = false;\n        if (isStroke) {\n            isHit = polyline_1.default(points, lineWidth, x, y, true);\n        }\n        if (!isHit && isFill) {\n            isHit = polygon_1.default(points, x, y);\n        }\n        return isHit;\n    };\n    Polygon.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var points = attrs.points;\n        if (points.length < 2) {\n            return;\n        }\n        context.beginPath();\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i];\n            if (i === 0) {\n                context.moveTo(point[0], point[1]);\n            }\n            else {\n                context.lineTo(point[0], point[1]);\n            }\n        }\n        context.closePath();\n    };\n    return Polygon;\n}(base_1.default));\nexports.default = Polygon;\n//# sourceMappingURL=polygon.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"./line\");\nfunction inPolyline(points, lineWidth, x, y, isClose) {\n    var count = points.length;\n    if (count < 2) {\n        return false;\n    }\n    for (var i = 0; i < count - 1; i++) {\n        var x1 = points[i][0];\n        var y1 = points[i][1];\n        var x2 = points[i + 1][0];\n        var y2 = points[i + 1][1];\n        if (line_1.default(x1, y1, x2, y2, lineWidth, x, y)) {\n            return true;\n        }\n    }\n    // 如果封闭，则计算起始点和结束点的边\n    if (isClose) {\n        var first = points[0];\n        var last = points[count - 1];\n        if (line_1.default(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.default = inPolyline;\n//# sourceMappingURL=polyline.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar g_math_1 = require(\"@antv/g-math\");\nvar g_math_2 = require(\"@antv/g-math\");\nvar util_1 = require(\"@antv/util\");\nvar base_1 = require(\"./base\");\nvar polyline_1 = require(\"../util/in-stroke/polyline\");\nvar ArrowUtil = require(\"../util/arrow\");\nvar PolyLine = /** @class */ (function (_super) {\n    tslib_1.__extends(PolyLine, _super);\n    function PolyLine() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PolyLine.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { startArrow: false, endArrow: false });\n    };\n    PolyLine.prototype.initAttrs = function (attrs) {\n        this.setArrow();\n    };\n    // 更新属性时，检测是否更改了 points\n    PolyLine.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        this.setArrow();\n        if (['points'].indexOf(name) !== -1) {\n            this._resetCache();\n        }\n    };\n    PolyLine.prototype._resetCache = function () {\n        this.set('totalLength', null);\n        this.set('tCache', null);\n    };\n    PolyLine.prototype.setArrow = function () {\n        var attrs = this.attr();\n        var _a = this.attrs, points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;\n        var length = points.length;\n        var x1 = points[0][0];\n        var y1 = points[0][1];\n        var x2 = points[length - 1][0];\n        var y2 = points[length - 1][1];\n        if (startArrow) {\n            ArrowUtil.addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);\n        }\n        if (endArrow) {\n            ArrowUtil.addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);\n        }\n    };\n    // 不允许 fill\n    PolyLine.prototype.isFill = function () {\n        return false;\n    };\n    PolyLine.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        // 没有设置 stroke 不能被拾取, 没有线宽不能被拾取\n        if (!isStroke || !lineWidth) {\n            return false;\n        }\n        var points = this.attr().points;\n        return polyline_1.default(points, lineWidth, x, y, false);\n    };\n    // 始终填充\n    PolyLine.prototype.isStroke = function () {\n        return true;\n    };\n    PolyLine.prototype.createPath = function (context) {\n        var _a = this.attr(), points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;\n        var length = points.length;\n        if (points.length < 2) {\n            return;\n        }\n        var x1 = points[0][0];\n        var y1 = points[0][1];\n        var x2 = points[length - 1][0];\n        var y2 = points[length - 1][1];\n        // 如果定义了箭头，并且是自定义箭头，线条相应缩进\n        if (startArrow && startArrow.d) {\n            var distance = ArrowUtil.getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);\n            x1 += distance.dx;\n            y1 += distance.dy;\n        }\n        if (endArrow && endArrow.d) {\n            var distance = ArrowUtil.getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);\n            x2 -= distance.dx;\n            y2 -= distance.dy;\n        }\n        context.beginPath();\n        context.moveTo(x1, y1);\n        for (var i = 0; i < length - 1; i++) {\n            var point = points[i];\n            context.lineTo(point[0], point[1]);\n        }\n        context.lineTo(x2, y2);\n    };\n    PolyLine.prototype.afterDrawPath = function (context) {\n        var startArrowShape = this.get('startArrowShape');\n        var endArrowShape = this.get('endArrowShape');\n        if (startArrowShape) {\n            startArrowShape.draw(context);\n        }\n        if (endArrowShape) {\n            endArrowShape.draw(context);\n        }\n    };\n    /**\n     * Get length of polyline\n     * @return {number} length\n     */\n    PolyLine.prototype.getTotalLength = function () {\n        var points = this.attr().points;\n        // get totalLength from cache\n        var totalLength = this.get('totalLength');\n        if (!util_1.isNil(totalLength)) {\n            return totalLength;\n        }\n        this.set('totalLength', g_math_2.Polyline.length(points));\n        return this.get('totalLength');\n    };\n    /**\n     * Get point according to ratio\n     * @param {number} ratio\n     * @return {Point} point\n     */\n    PolyLine.prototype.getPoint = function (ratio) {\n        var points = this.attr().points;\n        // get tCache from cache\n        var tCache = this.get('tCache');\n        if (!tCache) {\n            this._setTcache();\n            tCache = this.get('tCache');\n        }\n        var subt;\n        var index;\n        util_1.each(tCache, function (v, i) {\n            if (ratio >= v[0] && ratio <= v[1]) {\n                subt = (ratio - v[0]) / (v[1] - v[0]);\n                index = i;\n            }\n        });\n        return g_math_1.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);\n    };\n    PolyLine.prototype._setTcache = function () {\n        var points = this.attr().points;\n        if (!points || points.length === 0) {\n            return;\n        }\n        var totalLength = this.getTotalLength();\n        if (totalLength <= 0) {\n            return;\n        }\n        var tempLength = 0;\n        var tCache = [];\n        var segmentT;\n        var segmentL;\n        util_1.each(points, function (p, i) {\n            if (points[i + 1]) {\n                segmentT = [];\n                segmentT[0] = tempLength / totalLength;\n                segmentL = g_math_1.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n                tempLength += segmentL;\n                segmentT[1] = tempLength / totalLength;\n                tCache.push(segmentT);\n            }\n        });\n        this.set('tCache', tCache);\n    };\n    /**\n     * Get start tangent vector\n     * @return {Array}\n     */\n    PolyLine.prototype.getStartTangent = function () {\n        var points = this.attr().points;\n        var result = [];\n        result.push([points[1][0], points[1][1]]);\n        result.push([points[0][0], points[0][1]]);\n        return result;\n    };\n    /**\n     * Get end tangent vector\n     * @return {Array}\n     */\n    PolyLine.prototype.getEndTangent = function () {\n        var points = this.attr().points;\n        var l = points.length - 1;\n        var result = [];\n        result.push([points[l - 1][0], points[l - 1][1]]);\n        result.push([points[l][0], points[l][1]]);\n        return result;\n    };\n    return PolyLine;\n}(base_1.default));\nexports.default = PolyLine;\n//# sourceMappingURL=polyline.js.map","\n/**\n * @fileoverview 矩形\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar parse_1 = require(\"../util/parse\");\nvar util_1 = require(\"../util/util\");\nvar rect_1 = require(\"../util/in-stroke/rect\");\nvar rect_radius_1 = require(\"../util/in-stroke/rect-radius\");\nvar Rect = /** @class */ (function (_super) {\n    tslib_1.__extends(Rect, _super);\n    function Rect() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rect.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });\n    };\n    Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var minX = attrs.x;\n        var minY = attrs.y;\n        var width = attrs.width;\n        var height = attrs.height;\n        var radius = attrs.radius;\n        // 无圆角时的策略\n        if (!radius) {\n            var halfWidth = lineWidth / 2;\n            // 同时填充和带有边框\n            if (isFill && isStroke) {\n                return util_1.inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);\n            }\n            // 仅填充\n            if (isFill) {\n                return util_1.inBox(minX, minY, width, height, x, y);\n            }\n            if (isStroke) {\n                return rect_1.default(minX, minY, width, height, lineWidth, x, y);\n            }\n        }\n        else {\n            var isHit = false;\n            if (isStroke) {\n                isHit = rect_radius_1.default(minX, minY, width, height, radius, lineWidth, x, y);\n            }\n            // 仅填充时带有圆角的矩形直接通过图形拾取\n            // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n            if (!isHit && isFill) {\n                // TODO 简单判断，后续补\n                isHit = util_1.inBox(minX, minY, width, height, x, y);\n            }\n            return isHit;\n        }\n    };\n    Rect.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var x = attrs.x;\n        var y = attrs.y;\n        var width = attrs.width;\n        var height = attrs.height;\n        var radius = attrs.radius;\n        context.beginPath();\n        if (radius === 0) {\n            // 改成原生的rect方法\n            context.rect(x, y, width, height);\n        }\n        else {\n            var _a = parse_1.parseRadius(radius), r1 = _a[0], r2 = _a[1], r3 = _a[2], r4 = _a[3];\n            context.moveTo(x + r1, y);\n            context.lineTo(x + width - r2, y);\n            r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n            context.lineTo(x + width, y + height - r3);\n            r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n            context.lineTo(x + r4, y + height);\n            r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n            context.lineTo(x, y + r1);\n            r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n            context.closePath();\n        }\n    };\n    return Rect;\n}(base_1.default));\nexports.default = Rect;\n//# sourceMappingURL=rect.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nfunction inRect(minX, minY, width, height, lineWidth, x, y) {\n    var halfWidth = lineWidth / 2;\n    // 将四个边看做矩形来检测，比边的检测算法要快\n    return (util_1.inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边\n        util_1.inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边\n        util_1.inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边\n        util_1.inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)); // 左边\n}\nexports.default = inRect;\n//# sourceMappingURL=rect.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"./line\");\nvar arc_1 = require(\"./arc\");\nfunction rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {\n    var halfWidth = lineWidth / 2;\n    return (line_1.default(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) ||\n        line_1.default(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) ||\n        line_1.default(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) ||\n        line_1.default(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) ||\n        arc_1.default(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) ||\n        arc_1.default(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) ||\n        arc_1.default(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) ||\n        arc_1.default(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y));\n}\nexports.default = rectWithRadius;\n//# sourceMappingURL=rect-radius.js.map","\n/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util/util\");\nvar g_base_1 = require(\"@antv/g-base\");\nvar Text = /** @class */ (function (_super) {\n    tslib_1.__extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // 默认文本属性\n    Text.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });\n    };\n    // 仅仅使用包围盒检测来进行拾取\n    Text.prototype.isOnlyHitBox = function () {\n        return true;\n    };\n    // 初始化时组合 font，同时判断 text 是否换行\n    Text.prototype.initAttrs = function (attrs) {\n        this._assembleFont();\n        if (attrs.text) {\n            this._setText(attrs.text);\n        }\n    };\n    // 组装字体\n    Text.prototype._assembleFont = function () {\n        var attrs = this.attrs;\n        attrs.font = g_base_1.assembleFont(attrs);\n    };\n    // 如果文本换行，则缓存数组\n    Text.prototype._setText = function (text) {\n        var textArr = null;\n        if (util_1.isString(text) && text.indexOf('\\n') !== -1) {\n            textArr = text.split('\\n');\n        }\n        this.set('textArr', textArr);\n    };\n    // 更新属性时，检测是否更改了 font、text\n    Text.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name.startsWith('font')) {\n            this._assembleFont();\n        }\n        if (name === 'text') {\n            this._setText(value);\n        }\n    };\n    // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n    // createPath(context) {\n    // }\n    // 如果文本多行，需要获取文本间距\n    Text.prototype._getSpaceingY = function () {\n        var attrs = this.attrs;\n        var lineHeight = attrs.lineHeight;\n        var fontSize = attrs.fontSize * 1;\n        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n    };\n    // 绘制文本，考虑多行的场景\n    Text.prototype._drawTextArr = function (context, textArr, isFill) {\n        var attrs = this.attrs;\n        var textBaseline = attrs.textBaseline;\n        var x = attrs.x;\n        var y = attrs.y;\n        var fontSize = attrs.fontSize * 1;\n        var spaceingY = this._getSpaceingY();\n        var height = g_base_1.getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n        var subY;\n        util_1.each(textArr, function (subText, index) {\n            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n            if (textBaseline === 'middle')\n                subY += height - fontSize - (height - fontSize) / 2;\n            if (textBaseline === 'top')\n                subY += height - fontSize;\n            if (isFill) {\n                context.fillText(subText, x, subY);\n            }\n            else {\n                context.strokeText(subText, x, subY);\n            }\n        });\n    };\n    // 绘制文本，同时考虑填充和绘制边框\n    Text.prototype._drawText = function (context, isFill) {\n        var attrs = this.attr();\n        var x = attrs.x;\n        var y = attrs.y;\n        var textArr = this.get('textArr');\n        if (textArr) {\n            this._drawTextArr(context, textArr, isFill);\n        }\n        else {\n            var text = attrs.text;\n            if (isFill) {\n                context.fillText(text, x, y);\n            }\n            else {\n                context.strokeText(text, x, y);\n            }\n        }\n    };\n    // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n    Text.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = opacity;\n                }\n                this.stroke(context);\n            }\n        }\n        if (this.isFill()) {\n            if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    // 复写填充逻辑\n    Text.prototype.fill = function (context) {\n        this._drawText(context, true);\n    };\n    // 复写绘制边框的逻辑\n    Text.prototype.stroke = function (context) {\n        this._drawText(context, false);\n    };\n    return Text;\n}(base_1.default));\nexports.default = Text;\n//# sourceMappingURL=text.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar g_base_1 = require(\"@antv/g-base\");\nvar hit_1 = require(\"./util/hit\");\nvar Shape = require(\"./shape\");\nvar group_1 = require(\"./group\");\nvar util_1 = require(\"./util/util\");\nvar time_1 = require(\"./util/time\");\nvar draw_1 = require(\"./util/draw\");\nvar events_1 = require(\"./events\");\nvar mini_canvas_proxy_1 = require(\"./util/mini-canvas-proxy\");\nvar patch_1 = require(\"./patch\");\nvar Canvas = /** @class */ (function (_super) {\n    tslib_1.__extends(Canvas, _super);\n    function Canvas(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        var ctx = _this.get('context');\n        if (_this.isMini()) {\n            if (_this.isMiniNative()) {\n                // TODO 这里会传递过来extra，里面包含一些来自各个平台的优化函数\n                time_1.setExtraFunction(_this.get('extra'));\n            }\n            else {\n                // 小程序使用了自定义的canvas api，不兼容w3c标准\n                _this.set('context', new Proxy(ctx, new mini_canvas_proxy_1.default()));\n            }\n            // 架构调整前，打一些patch\n            patch_1.default(ctx, _this);\n        }\n        return _this;\n    }\n    Canvas.prototype.isMiniNative = function () {\n        return this.get('renderer') === 'mini-native';\n    };\n    Canvas.prototype.isMini = function () {\n        return this.get('renderer').startsWith('mini');\n    };\n    Canvas.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        // 设置渲染引擎为 canvas(h5)/mini(小程序)，只读属性\n        cfg['renderer'] = 'canvas';\n        // 是否自动绘制，不需要用户调用 draw 方法\n        cfg['autoDraw'] = true;\n        // 是否允许局部刷新图表\n        cfg['localRefresh'] = true;\n        cfg['refreshElements'] = [];\n        // 是否在视图内自动裁剪\n        cfg['clipView'] = true;\n        // 是否使用快速拾取的方案，默认为 false，上层可以打开\n        cfg['quickHit'] = false;\n        // 给一个默认的rect，防止出现问题\n        cfg['boundingClientRect'] = {\n            width: 0,\n            height: 0,\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n        };\n        return cfg;\n    };\n    /**\n     * @protected\n     * 初始化绑定的事件\n     */\n    Canvas.prototype.initEvents = function () {\n        var eventController = new events_1.default({\n            canvas: this,\n        });\n        this.set('eventController', eventController);\n    };\n    Canvas.prototype.registerEventCallback = function (e) {\n        var eventController = this.get('eventController');\n        eventController.handleEvent(e);\n    };\n    /**\n     * @protected\n     * 清理所有的事件\n     */\n    Canvas.prototype.clearEvents = function () {\n        var eventController = this.get('eventController');\n        eventController.destroy();\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Canvas.prototype.onCanvasChange = function (changeType) {\n        /**\n         * 触发画布更新的三种 changeType\n         * 1. attr: 修改画布的绘图属性\n         * 2. sort: 画布排序，图形的层次会发生变化\n         * 3. changeSize: 改变画布大小\n         */\n        if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {\n            this.set('refreshElements', [this]);\n            this.draw();\n        }\n    };\n    Canvas.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Canvas.prototype.getGroupBase = function () {\n        return group_1.default;\n    };\n    /**\n     * 获取屏幕像素比\n     */\n    Canvas.prototype.getPixelRatio = function () {\n        var pixelRatio = this.get('pixelRatio') || util_1.getPixelRatio();\n        // 不足 1 的取 1，超出 1 的取整\n        return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;\n    };\n    Canvas.prototype.getViewRange = function () {\n        return {\n            minX: 0,\n            minY: 0,\n            maxX: this.cfg.width,\n            maxY: this.cfg.height,\n        };\n    };\n    Canvas.prototype.initDom = function () {\n        if (this.isMini()) {\n            var context = this.get('context');\n            var fitView = this.get('fitView');\n            var pixelRatio = this.getPixelRatio();\n            // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\n            // 上层框架控制 fitView，画布缩放会冲突（小程序没传 container，因此画布与container根据pixelRatio同比放大来实现高清的方案在小程序端自行维护）\n            if (!fitView && pixelRatio > 1) {\n                context.scale(pixelRatio, pixelRatio);\n            }\n            return;\n        }\n        _super.prototype.initDom.call(this);\n    };\n    // 复写基类的方法生成标签（非 mini renderer 的 super.initDom 调用）\n    Canvas.prototype.createDom = function () {\n        var element = document.createElement('canvas');\n        var context = element.getContext('2d');\n        // 缓存 context 对象\n        this.set('context', context);\n        return element;\n    };\n    Canvas.prototype.setDOMSize = function (width, height) {\n        _super.prototype.setDOMSize.call(this, width, height);\n        var context = this.get('context');\n        var el = this.get('el');\n        var pixelRatio = this.getPixelRatio();\n        el.width = pixelRatio * width;\n        el.height = pixelRatio * height;\n        // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\n        if (pixelRatio > 1) {\n            context.scale(pixelRatio, pixelRatio);\n        }\n    };\n    // 复写基类方法\n    Canvas.prototype.clear = function () {\n        _super.prototype.clear.call(this);\n        this._clearFrame(); // 需要清理掉延迟绘制的帧\n        var context = this.get('context');\n        context.clearRect(0, 0, this.get('width'), this.get('height'));\n    };\n    Canvas.prototype.getShape = function (x, y) {\n        var shape;\n        if (this.get('quickHit')) {\n            shape = hit_1.getShape(this, x, y);\n        }\n        else {\n            shape = _super.prototype.getShape.call(this, x, y, null);\n        }\n        return shape;\n    };\n    // 对绘制区域边缘取整，避免浮点数问题\n    Canvas.prototype._getRefreshRegion = function () {\n        var elements = this.get('refreshElements');\n        var viewRegion = this.getViewRange();\n        var region;\n        // 如果是当前画布整体发生了变化，则直接重绘整个画布\n        if (elements.length && elements[0] === this) {\n            region = viewRegion;\n        }\n        else {\n            region = draw_1.getMergedRegion(elements);\n            if (region) {\n                region.minX = Math.floor(region.minX);\n                region.minY = Math.floor(region.minY);\n                region.maxX = Math.ceil(region.maxX);\n                region.maxY = Math.ceil(region.maxY);\n                region.maxY += 1; // 在很多环境下字体的高低会不一致，附加一像素，避免残影\n                var clipView = this.get('clipView');\n                // 自动裁剪不在 view 内的区域\n                if (clipView) {\n                    region = draw_1.mergeView(region, viewRegion);\n                }\n            }\n        }\n        return region;\n    };\n    // 清理还在进行的绘制\n    Canvas.prototype._clearFrame = function () {\n        var drawFrame = this.get('drawFrame');\n        if (drawFrame) {\n            // 如果全部渲染时，存在局部渲染，则抛弃掉局部渲染\n            time_1.clearAnimationFrame(drawFrame);\n            this.set('drawFrame', null);\n            this.set('refreshElements', []);\n        }\n    };\n    // 手工调用绘制接口\n    Canvas.prototype.draw = function () {\n        var drawFrame = this.get('drawFrame');\n        if (this.get('autoDraw') && drawFrame) {\n            return;\n        }\n        this._startDraw();\n    };\n    // 触发绘制\n    Canvas.prototype._startDraw = function () {\n        var _this = this;\n        var drawFrame = this.get('drawFrame');\n        if (!drawFrame) {\n            drawFrame = time_1.requestAnimationFrame(function () {\n                if (_this.get('localRefresh')) {\n                    _this._drawRegion();\n                }\n                else {\n                    _this._drawAll();\n                }\n                // 可能存在setInterval的情况\n                time_1.clearAnimationFrame(drawFrame);\n                _this.set('drawFrame', null);\n            });\n            this.set('drawFrame', drawFrame);\n        }\n    };\n    // 绘制局部\n    Canvas.prototype._drawRegion = function () {\n        var context = this.get('context');\n        var refreshElements = this.get('refreshElements');\n        var children = this.getChildren();\n        var region = this._getRefreshRegion();\n        // 需要注意可能没有 region 的场景\n        // 一般发生在设置了 localRefresh ,在没有图形发生变化的情况下，用户调用了 draw\n        if (region) {\n            // 清理指定区域\n            context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n            // 保存上下文，设置 clip\n            context.save();\n            context.beginPath();\n            context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n            context.clip();\n            draw_1.applyAttrsToContext(context, this);\n            // 确认更新的元素，这个优化可以提升 10 倍左右的性能，10W 个带有 group 的节点，局部渲染会从 90ms 下降到 5-6 ms\n            draw_1.checkRefresh(this, children, region);\n            // 绘制子元素\n            draw_1.drawChildren(context, children, region);\n            context.restore();\n        }\n        else if (refreshElements.length) {\n            // 防止发生改变的 elements 没有 region 的场景，这会发生在多个情况下\n            // 1. 空的 group\n            // 2. 所有 elements 没有在绘图区域\n            // 3. group 下面的 elements 隐藏掉\n            // 如果不进行清理 hasChanged 的状态会不正确\n            draw_1.clearChanged(refreshElements);\n        }\n        util_1.each(refreshElements, function (element) {\n            if (element.get('hasChanged')) {\n                // 在视窗外的 Group 元素会加入到更新队列里，但实际却没有执行 draw() 逻辑，也就没有清除 hasChanged 标记\n                // 即已经重绘完、但 hasChanged 标记没有清除的元素，需要统一清除掉。主要是 Group 存在问题，具体原因待排查\n                element.set('hasChanged', false);\n            }\n        });\n        // 针对小程序需要手动调用一次draw方法\n        if (this.isMini() && !this.isMiniNative()) {\n            context.draw(true);\n        }\n        this.set('refreshElements', []);\n    };\n    // 绘制所有图形\n    Canvas.prototype._drawAll = function () {\n        var context = this.get('context');\n        var children = this.getChildren();\n        context.clearRect(0, 0, this.get('width'), this.get('height'));\n        draw_1.applyAttrsToContext(context, this);\n        draw_1.drawChildren(context, children);\n        // 针对小程序需要手动调用一次draw方法\n        if (this.isMini() && !this.isMiniNative()) {\n            context.draw(true);\n        }\n        // 对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也会记录更新的元素队列，因此全局渲染完后也需要置空\n        this.set('refreshElements', []);\n    };\n    Canvas.prototype.skipDraw = function () { };\n    /**\n     * 刷新图形元素，这里仅仅是放入队列，下次绘制时进行绘制\n     * @param {IElement} element 图形元素\n     */\n    Canvas.prototype.refreshElement = function (element) {\n        var refreshElements = this.get('refreshElements');\n        refreshElements.push(element);\n        // if (this.get('autoDraw')) {\n        //   this._startDraw();\n        // }\n    };\n    // 实现接口\n    Canvas.prototype.getPointByEvent = function (ev) {\n        if (this.isMini()) {\n            var _a = this.getClientByEvent(ev), clientX = _a.x, clientY = _a.y;\n            return this.getPointByClient(clientX, clientY);\n        }\n        return _super.prototype.getPointByEvent.call(this, ev);\n    };\n    // 获取 touch 事件的 clientX 和 clientY 需要单独处理\n    Canvas.prototype.getClientByEvent = function (event) {\n        // 这里需要转换成原始event\n        var ev = event.srcEvent;\n        var clientInfo = null;\n        if (ev.touches) {\n            if (ev.type === 'touchend') {\n                clientInfo = ev.changedTouches[0];\n            }\n            else {\n                clientInfo = ev.touches[0];\n            }\n        }\n        if (!clientInfo) {\n            return {};\n        }\n        return {\n            x: clientInfo.clientX,\n            y: clientInfo.clientY,\n        };\n    };\n    // 实现接口\n    Canvas.prototype.getPointByClient = function (clientX, clientY) {\n        if (this.isMini()) {\n            var rect = this.get('boundingClientRect');\n            return {\n                x: clientX + rect.left,\n                y: clientY + rect.top,\n            };\n        }\n        var el = this.get('el');\n        var bbox = el.getBoundingClientRect();\n        return {\n            x: clientX - bbox.left,\n            y: clientY - bbox.top,\n        };\n    };\n    // 实现接口\n    Canvas.prototype.getClientByPoint = function (x, y) {\n        if (this.isMini()) {\n            // 小程序内需计算处理canvas的位置信息\n            var rect = this.get('boundingClientRect');\n            return {\n                x: x + rect.left,\n                y: y + rect.top,\n            };\n        }\n        var el = this.get('el');\n        var bbox = el.getBoundingClientRect();\n        return {\n            x: x + bbox.left,\n            y: y + bbox.top,\n        };\n    };\n    return Canvas;\n}(g_base_1.AbstractCanvas));\nexports.default = Canvas;\n//# sourceMappingURL=canvas.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getShape = void 0;\nvar g_base_1 = require(\"@antv/g-base\");\nfunction invertFromMatrix(v, matrix) {\n    if (matrix) {\n        var invertMatrix = g_base_1.invert(matrix);\n        return g_base_1.multiplyVec2(invertMatrix, v);\n    }\n    return v;\n}\nfunction getRefXY(element, x, y) {\n    // @ts-ignore\n    var totalMatrix = element.getTotalMatrix();\n    if (totalMatrix) {\n        var _a = invertFromMatrix([x, y, 1], totalMatrix), refX = _a[0], refY = _a[1];\n        return [refX, refY];\n    }\n    return [x, y];\n}\n// 拾取前的检测，只有通过检测才能继续拾取\nfunction preTest(element, x, y) {\n    // @ts-ignore\n    if (element.isCanvas && element.isCanvas()) {\n        return true;\n    }\n    // 不允许被拾取，则返回 null\n    // @ts-ignore\n    if (!g_base_1.isAllowCapture(element) || element.cfg.isInView === false) {\n        return false;\n    }\n    if (element.cfg.clipShape) {\n        // 如果存在 clip\n        var _a = getRefXY(element, x, y), refX = _a[0], refY = _a[1];\n        if (element.isClipped(refX, refY)) {\n            return false;\n        }\n    }\n    // @ts-ignore ，这个地方调用过于频繁\n    var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();\n    // 如果没有缓存 bbox，则说明不可见\n    // 注释掉的这段可能会加速拾取，上面的语句改写成 const bbox = element.cfg.cacheCanvasBBox;\n    // 这时候的拾取假设图形/分组在上一次绘制都在视窗内，但是上面已经判定了 isInView 所以意义不大\n    // 现在还调用 element.getCanvasBBox(); 一个很大的原因是便于单元测试\n    // if (!bbox) {\n    //   return false;\n    // }\n    if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {\n        return false;\n    }\n    return true;\n}\n// 这个方法复写了 g-base 的 getShape\nfunction getShape(container, x, y) {\n    // 没有通过检测，则返回 null\n    if (!preTest(container, x, y)) {\n        return null;\n    }\n    var shape = null;\n    var children = container.getChildren();\n    var count = children.length;\n    for (var i = count - 1; i >= 0; i--) {\n        var child = children[i];\n        if (child.isGroup()) {\n            shape = getShape(child, x, y);\n        }\n        else if (preTest(child, x, y)) {\n            var curShape = child;\n            var _a = getRefXY(child, x, y), refX = _a[0], refY = _a[1];\n            // @ts-ignore\n            if (curShape.isInShape(refX, refY)) {\n                shape = child;\n            }\n        }\n        if (shape) {\n            break;\n        }\n    }\n    return shape;\n}\nexports.getShape = getShape;\n//# sourceMappingURL=hit.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar g6_hammerjs_1 = require(\"g6-hammerjs\");\nvar g_base_1 = require(\"@antv/g-base\");\nvar util_1 = require(\"./util/util\");\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\n// 是否有委托事件监听\nfunction hasDelegation(events, type) {\n    for (var key in events) {\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\n// 触发目标事件，目标只能是 shape 或 canvas\nfunction emitTargetEvent(target, type, eventObj) {\n    eventObj.name = type;\n    eventObj.target = target;\n    eventObj.currentTarget = target;\n    eventObj.delegateTarget = target;\n    target.emit(type, eventObj);\n}\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\nfunction bubbleEvent(container, type, eventObj) {\n    if (eventObj.bubbles) {\n        var relativeShape = void 0;\n        var isOverEvent = false;\n        if (container.isCanvas() && isOverEvent) {\n            return;\n        }\n        // 如果相关图形同当前图形在同一个容器内，不触发事件\n        if (relativeShape && util_1.isParent(container, relativeShape)) {\n            // 阻止继续向上冒泡\n            eventObj.bubbles = false;\n            return;\n        }\n        // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n        eventObj.name = type;\n        eventObj.currentTarget = container;\n        eventObj.delegateTarget = container;\n        container.emit(type, eventObj);\n    }\n}\nvar EventController = /** @class */ (function () {\n    function EventController(cfg) {\n        var _this = this;\n        // 正在被拖拽的图形\n        this.draggingShape = null;\n        this.dragging = false;\n        // 当前鼠标/touch所在位置的图形\n        this.currentShape = null;\n        this.panstartShape = null;\n        this.panstartPoint = null;\n        // 统一处理所有的回调\n        this.handleEvent = function (ev) {\n            _this.hammerRuntime.emit(\"origin_input:\" + ev.type, ev);\n        };\n        this.canvas = cfg.canvas;\n        this._initEvent();\n    }\n    EventController.prototype._initEvent = function () {\n        var _this = this;\n        this.hammerRuntime = new g6_hammerjs_1.default({}, {\n            inputClass: g6_hammerjs_1.TouchInput,\n        });\n        this.hammerRuntime.add(new g6_hammerjs_1.default.Pan({ threshold: 0, pointers: 1 }));\n        this.hammerRuntime.add(new g6_hammerjs_1.default.Swipe()).recognizeWith(this.hammerRuntime.get('pan'));\n        //this.hammerRuntime.add(new Hammer.Rotate({ threshold: 0 })).recognizeWith(this.hammerRuntime.get('pan'));\n        this.hammerRuntime.add(new g6_hammerjs_1.default.Pinch({ threshold: 0, pointers: 2 }));\n        //.recognizeWith([this.hammerRuntime.get('pan'), this.hammerRuntime.get('rotate')]);\n        this.hammerRuntime.add(new g6_hammerjs_1.default.Tap({ event: 'doubletap', taps: 2 }));\n        this.hammerRuntime.add(new g6_hammerjs_1.default.Tap());\n        this.hammerRuntime.on('panstart panmove panend pancancel', function (e) {\n            e.srcEvent.extra = e;\n            var pointInfo = _this._getPointInfo(e);\n            var shape = _this._getShape(pointInfo, e);\n            // 结束拖拽\n            if (e.type === 'panend' || e.type === 'pancancel') {\n                _this._onpanend(pointInfo, shape, e);\n            }\n            // 开始拖拽\n            if (e.type === 'panstart') {\n                // 兜底, hammer解析的事件可能缺失一次panend，所以做个兜底\n                if (_this.dragging) {\n                    _this.draggingShape = null;\n                    _this.dragging = false;\n                    _this.panstartShape = null;\n                    _this.panstartPoint = null;\n                }\n                _this._onpanstart(pointInfo, shape, e);\n            }\n            // 拖拽中\n            if (e.type === 'panmove') {\n                _this._onpanmove(pointInfo, shape, e);\n            }\n            _this.currentShape = shape;\n        });\n        this.hammerRuntime.on('swipe', function (e) {\n            _this._emitMobileEvent(e.type, e);\n        });\n        this.hammerRuntime.on('rotatestart rotatemove', function (e) {\n            _this._emitMobileEvent(e.type, e);\n        });\n        this.hammerRuntime.on('pinchstart pinchmove pinchend pinchcancel', function (e) {\n            if (e.type === 'pinchend' || e.type === 'pinchcancel') {\n                _this._emitMobileEvent(e.type, e);\n                return;\n            }\n            e.srcEvent.extra = {\n                scale: e.scale,\n            };\n            _this._emitMobileEvent(e.type, e);\n        });\n        this.hammerRuntime.on('doubletap', function (e) {\n            _this._emitMobileEvent(e.type, e);\n        });\n        this.hammerRuntime.on('tap', function (e) {\n            _this._emitMobileEvent(e.type, e);\n        });\n    };\n    EventController.prototype._emitMobileEvent = function (type, ev) {\n        var pointInfo = this._getPointInfo(ev);\n        var shape = this._getShape(pointInfo, ev);\n        this._emitEvent(type, ev, pointInfo, shape);\n    };\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n        var eventObj = new g_base_1.Event(type, event);\n        eventObj.fromShape = fromShape;\n        eventObj.toShape = toShape;\n        eventObj.x = point.x;\n        eventObj.y = point.y;\n        eventObj.clientX = point.clientX;\n        eventObj.clientY = point.clientY;\n        eventObj.propagationPath.push(target);\n        // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n        return eventObj;\n    };\n    // 根据点获取图形，提取成独立方法，便于后续优化\n    EventController.prototype._getShape = function (point, event) {\n        var ev = event.srcEvent;\n        return this.canvas.getShape(point.x, point.y, ev);\n    };\n    // 获取事件的当前点的信息\n    EventController.prototype._getPointInfo = function (ev) {\n        var canvas = this.canvas;\n        var clientPoint = canvas.getClientByEvent(ev);\n        var point = canvas.getPointByEvent(ev);\n        return {\n            x: point.x,\n            y: point.y,\n            clientX: clientPoint.x,\n            clientY: clientPoint.y,\n        };\n    };\n    // 触发事件\n    EventController.prototype._triggerEvent = function (type, ev) {\n        var pointInfo = this._getPointInfo(ev);\n        // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n        var shape = this._getShape(pointInfo, ev);\n        var method = this[\"_on\" + type];\n        if (method) {\n            method.call(this, pointInfo, shape, ev);\n        }\n        else {\n            var preShape = this.currentShape;\n            // 如果进入、移出画布时存在图形，则要分别触发事件\n            if (type === 'panstart' || type === 'dragenter') {\n                this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n                if (shape) {\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n                }\n                if (type === 'panstart' && this.draggingShape) {\n                    // 如果正在拖拽图形, 则触发 dragleave\n                    this._emitEvent('dragenter', ev, pointInfo, null);\n                }\n            }\n            else if (type === 'panend' || type === 'dragleave') {\n                if (preShape) {\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n                }\n                this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n                if (type === 'panend' && this.draggingShape) {\n                    this._emitEvent('dragleave', ev, pointInfo, null);\n                }\n            }\n            else {\n                this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n            }\n        }\n    };\n    // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n    EventController.prototype._onpanstart = function (pointInfo, shape, event) {\n        this.panstartShape = shape;\n        this.panstartPoint = pointInfo;\n        this.panstartTimeStamp = event.timeStamp;\n        this._emitEvent('panstart', event, pointInfo, shape, null, null);\n    };\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n        if (toShape) {\n            if (toShape !== fromShape) {\n                if (fromShape) {\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n                }\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n            if (!isCanvasEmit) {\n                this._emitEvent('dragover', event, pointInfo, toShape);\n            }\n        }\n        else if (fromShape) {\n            // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n            // 经过空白区域\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        if (isCanvasEmit) {\n            this._emitEvent('dragover', event, pointInfo, toShape);\n        }\n    };\n    // drag 完成后，需要做一些清理工作\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n        if (draggingShape) {\n            draggingShape.set('capture', true); // 恢复可以拾取\n            this.draggingShape = null;\n        }\n        this.dragging = false;\n        // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n        var shape = this._getShape(pointInfo, event);\n        this.currentShape = shape;\n    };\n    // 按键抬起时，会终止拖拽、触发点击\n    EventController.prototype._onpanend = function (pointInfo, shape, event) {\n        var draggingShape = this.draggingShape;\n        if (this.dragging) {\n            // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n            if (draggingShape) {\n                this._emitEvent('drop', event, pointInfo, shape);\n            }\n            this._emitEvent('dragend', event, pointInfo, draggingShape);\n            this._afterDrag(draggingShape, pointInfo, event);\n        }\n        this._emitEvent('panend', event, pointInfo, shape);\n        this.panstartShape = null;\n        this.panstartPoint = null;\n    };\n    // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n    EventController.prototype._ondragover = function (pointInfo, shape, event) {\n        event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n        var preShape = this.currentShape;\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n    };\n    // 大量的图形事件，都通过 mousemove 模拟\n    EventController.prototype._onpanmove = function (pointInfo, shape, event) {\n        var canvas = this.canvas;\n        var preShape = this.currentShape;\n        var draggingShape = this.draggingShape;\n        // 正在拖拽时\n        if (this.dragging) {\n            // 正在拖拽中\n            if (draggingShape) {\n                // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n            }\n            // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n            // 否则在 canvas 上触发 drag 事件\n            this._emitEvent('drag', event, pointInfo, draggingShape);\n        }\n        else {\n            var panstartPoint = this.panstartPoint;\n            if (panstartPoint) {\n                // 当鼠标点击下去，同时移动时，进行 drag 判定\n                var panstartShape = this.panstartShape;\n                var now = event.timeStamp;\n                var timeWindow = now - this.panstartTimeStamp;\n                var dx = panstartPoint.clientX - pointInfo.clientX;\n                var dy = panstartPoint.clientY - pointInfo.clientY;\n                var dist = dx * dx + dy * dy;\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\n                    if (panstartShape && panstartShape.get('draggable')) {\n                        // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n                        draggingShape = this.panstartShape; // 拖动鼠标点下时的 shape\n                        draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n                        this.draggingShape = draggingShape;\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\n                        // 清理按下鼠标时缓存的值\n                        this.panstartShape = null;\n                        this.panstartPoint = null;\n                    }\n                    else if (!panstartShape && canvas.get('draggable')) {\n                        // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, null);\n                        // 清理按下鼠标时缓存的值\n                        this.panstartShape = null;\n                        this.panstartPoint = null;\n                    }\n                    else {\n                        this._emitEvent('panmove', event, pointInfo, shape);\n                    }\n                }\n            }\n        }\n        this._emitEvent('panmove', event, pointInfo, shape);\n    };\n    // 触发事件\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n        // 存在 shape 触发，则进行冒泡处理\n        if (shape) {\n            eventObj.shape = shape;\n            // 触发 shape 上的事件\n            emitTargetEvent(shape, type, eventObj);\n            var parent_1 = shape.getParent();\n            // 执行冒泡\n            while (parent_1) {\n                // 委托事件要先触发\n                parent_1.emitDelegation(type, eventObj);\n                // 事件冒泡停止，不能妨碍委托事件\n                if (!eventObj.propagationStopped) {\n                    bubbleEvent(parent_1, type, eventObj);\n                }\n                eventObj.propagationPath.push(parent_1);\n                parent_1 = parent_1.getParent();\n            }\n        }\n        else {\n            // 如果没有 shape 直接在 canvas 上触发\n            var canvas = this.canvas;\n            // 直接触发 canvas 上的事件\n            emitTargetEvent(canvas, type, eventObj);\n        }\n    };\n    EventController.prototype.destroy = function () {\n        // 清理缓存的对象\n        this.canvas = null;\n        this.currentShape = null;\n        this.draggingShape = null;\n        this.panstartPoint = null;\n        this.panstartShape = null;\n        this.panstartTimeStamp = null;\n    };\n    return EventController;\n}());\nexports.default = EventController;\n//# sourceMappingURL=events.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/***\n * 小程序canvas的handler，用于做兼容兜底\n */\nvar MiniCanvasProxy = /** @class */ (function () {\n    function MiniCanvasProxy() {\n    }\n    MiniCanvasProxy.prototype.set = function (obj, prop, value) {\n        switch (prop) {\n            case 'strokeStyle':\n                obj['setStrokeStyle'](value);\n                break;\n            case 'fillStyle':\n                obj['setFillStyle'](value);\n                break;\n            case 'lineWidth':\n                obj['setLineWidth'](value);\n                break;\n            case 'lineDash':\n                obj['setLineDash'](value);\n                break;\n            case 'globalAlpha':\n                if (value || value === 0) {\n                    obj['globalAlpha'] = value;\n                    obj['setGlobalAlpha'](value);\n                }\n                break;\n            case 'fontSize':\n                obj['setFontSize'](value);\n                break;\n            case 'textAlign':\n                obj['setTextAlign'](value);\n                break;\n            case 'fontStyle':\n            case 'font':\n                obj['setFont'](value);\n                break;\n            case 'textBaseline':\n                obj['setTextBaseline'](value);\n                break;\n            default:\n                obj[prop] = value;\n        }\n        return true;\n    };\n    MiniCanvasProxy.prototype.get = function (obj, prop) {\n        if (prop === 'globalAlpha' && obj[prop] === undefined)\n            return 1;\n        if (typeof obj[prop] === 'function') {\n            return obj[prop].bind(obj);\n        }\n        return obj[prop];\n    };\n    return MiniCanvasProxy;\n}());\nexports.default = MiniCanvasProxy;\n//# sourceMappingURL=mini-canvas-proxy.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = require(\"./bbox\");\nvar image_1 = require(\"../shape/image\");\nexports.default = (function (context, canvas) {\n    image_1.setMiniCanvas(canvas);\n    bbox_1.default(context);\n});\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar g_base_1 = require(\"@antv/g-base\");\nvar text_1 = require(\"./text\");\nexports.default = (function (context) {\n    text_1.cacheCanvasContext(context);\n    g_base_1.registerBBox('text', text_1.default);\n});\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cacheCanvasContext = void 0;\nvar util_1 = require(\"@antv/util\");\nvar text_1 = require(\"@antv/g-base/lib/util/text\");\nvar context = null;\nfunction cacheCanvasContext(ctx) {\n    context = ctx;\n}\nexports.cacheCanvasContext = cacheCanvasContext;\n/**\n * 字体宽度\n * @param text 文本\n * @param font 字体\n */\nfunction getTextWidth(text, font) {\n    var width = 0;\n    // null 或者 undefined 时，宽度为 0\n    if (util_1.isNil(text) || text === '') {\n        return width;\n    }\n    context.save();\n    context.font = font;\n    if (util_1.isString(text) && text.includes('\\n')) {\n        var textArr = text.split('\\n');\n        util_1.each(textArr, function (subText) {\n            var measureWidth = context.measureText(subText).width;\n            if (width < measureWidth) {\n                width = measureWidth;\n            }\n        });\n    }\n    else {\n        width = context.measureText(text).width;\n    }\n    context.restore();\n    return width;\n}\nfunction default_1(shape) {\n    var attrs = shape.attr();\n    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;\n    var font = attrs.font;\n    if (!font) {\n        // 如果未组装 font\n        font = text_1.assembleFont(attrs);\n    }\n    var width = getTextWidth(text, font);\n    var bbox;\n    if (!width) {\n        // 如果width不存在，四点共其实点\n        bbox = {\n            x: x,\n            y: y,\n            width: 0,\n            height: 0,\n        };\n    }\n    else {\n        var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;\n        var height = text_1.getTextHeight(text, fontSize, lineHeight); // attrs.height\n        // 默认左右对齐：left, 默认上下对齐 bottom\n        var point = {\n            x: x,\n            y: y - height,\n        };\n        if (textAlign) {\n            if (textAlign === 'end' || textAlign === 'right') {\n                point.x -= width;\n            }\n            else if (textAlign === 'center') {\n                point.x -= width / 2;\n            }\n        }\n        if (textBaseline) {\n            if (textBaseline === 'top') {\n                point.y += height;\n            }\n            else if (textBaseline === 'middle') {\n                point.y += height / 2;\n            }\n        }\n        bbox = {\n            x: point.x,\n            y: point.y,\n            width: width,\n            height: height,\n        };\n    }\n    return bbox;\n}\nexports.default = default_1;\n//# sourceMappingURL=text.js.map"]}