{"version":3,"sources":["index.js","hammer.js","utils/if-undefined.js","touchactionjs/touchaction-Consts.js","utils/utils-consts.js","touchactionjs/get-touchaction-props.js","inputjs/input-consts.js","recognizers/rotate.js","recognizers/attribute.js","recognizerjs/recognizer-constructor.js","recognizerjs/recognizer-consts.js","utils/assign.js","utils/unique-id.js","utils/invoke-array-arg.js","utils/each.js","utils/in-array.js","utils/bool-or-fn.js","recognizerjs/get-recognizer-by-name-if-manager.js","recognizerjs/state-str.js","recognizers/pinch.js","recognizers/swipe.js","recognizers/pan.js","recognizerjs/direction-str.js","recognizers/tap.js","utils/set-timeout-context.js","utils/bind-fn.js","inputjs/get-distance.js","recognizers/press.js","manager.js","touchactionjs/touchaction-constructor.js","utils/in-str.js","touchactionjs/clean-touch-actions.js","inputjs/create-input-instance.js","inputjs/input-handler.js","inputjs/compute-input-data.js","utils/has-parent.js","inputjs/simple-clone-input-data.js","inputjs/get-center.js","inputjs/get-angle.js","inputjs/get-direction.js","inputjs/compute-delta-xy.js","inputjs/get-velocity.js","inputjs/get-scale.js","inputjs/get-rotation.js","inputjs/compute-interval-input-data.js","input/touch.js","inputjs/input-constructor.js","utils/add-event-listeners.js","utils/split-str.js","utils/to-array.js","utils/unique-array.js","input/pointerevent.js","utils/remove-event-listeners.js","utils/merge.js","utils/deprecate.js","utils/extend.js","utils/inherit.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA,AENA;AHUA,ADGA,AGTA,ADGA,AENA;AHUA,ADGA,AGTA,ADGA,AENA;AHUA,ADGA,AKfA,AFMA,ADGA,AENA;AHUA,ADGA,AKfA,AFMA,ADGA,AENA;AHUA,ADGA,AKfA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ADGA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ADGA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ADGA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ACHA,AFMA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ACHA,AFMA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ACHA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AENA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AENA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AENA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ADGA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ADGA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ADGA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AFMA,AFMA;AFOA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA;AFOA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA;AFOA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA;AV+BA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA;AV+BA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA;AV+BA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA,ACHA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA,ACHA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,ACHA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AENA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AENA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AENA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ADGA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ADGA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ADGA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AWjCA,ARwBA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AWjCA,ARwBA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AWjCA,ARwBA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AGTA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AGTA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AGTA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,Ac1CA,AXiCA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,Ac1CA,AXiCA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,Ac1CA,AXiCA,ACHA,AS3BA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,A0B9EA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA,ALeA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA,ALeA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,AYpCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,ACHA,AGTA,ARwBA,AnByDA,AYpCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,ACHA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,ACHA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AKfA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AKfA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AKfA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AwCxHA,ANkBA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AwCxHA,ANkBA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AwCxHA,ANkBA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AFMA,AMlBA,ADGA,AENA,AENA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AFMA,AMlBA,ADGA,AENA,AENA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AENA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AGTA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AGTA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AGTA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA;AWhCA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AWhCA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AWhCA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,AKfA,AbuCA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,AKfA,AbuCA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AbuCA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA;AgB/CA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA;AFOA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA;AFOA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA;AFOA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA;AHUA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA;AHUA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA;AHUA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA;AJaA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA;AJaA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA;AJaA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,AGTA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ALgBA,ALeA,ANkBA,AU9BA,ADGA,AGTA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ALgBA,ALeA,ANkBA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AKfA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AKfA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AKfA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AMlBA,ADGA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AMlBA,ADGA,AHSA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AMlBA,ADGA,AHSA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ADGA,ADGA,AHSA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ADGA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ADGA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,AFMA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,AFMA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,AFMA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AkBtDA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AkBtDA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,ADGA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AJYA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AJYA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AJYA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _hammer = _interopRequireDefault(require(\"./hammer\"));\n\nvar _assign = _interopRequireDefault(require(\"./utils/assign\"));\n\nvar _inputConsts = require(\"./inputjs/input-consts\");\n\nvar _recognizerConsts = require(\"./recognizerjs/recognizer-consts\");\n\nvar _manager = _interopRequireDefault(require(\"./manager\"));\n\nvar _inputConstructor = _interopRequireDefault(require(\"./inputjs/input-constructor\"));\n\nvar _touchactionConstructor = _interopRequireDefault(require(\"./touchactionjs/touchaction-constructor\"));\n\nvar _touch = _interopRequireDefault(require(\"./input/touch\"));\n\nvar _pointerevent = _interopRequireDefault(require(\"./input/pointerevent\"));\n\nvar _recognizerConstructor = _interopRequireDefault(require(\"./recognizerjs/recognizer-constructor\"));\n\nvar _attribute = _interopRequireDefault(require(\"./recognizers/attribute\"));\n\nvar _tap = _interopRequireDefault(require(\"./recognizers/tap\"));\n\nvar _pan = _interopRequireDefault(require(\"./recognizers/pan\"));\n\nvar _swipe = _interopRequireDefault(require(\"./recognizers/swipe\"));\n\nvar _pinch = _interopRequireDefault(require(\"./recognizers/pinch\"));\n\nvar _rotate = _interopRequireDefault(require(\"./recognizers/rotate\"));\n\nvar _press = _interopRequireDefault(require(\"./recognizers/press\"));\n\nvar _addEventListeners = _interopRequireDefault(require(\"./utils/add-event-listeners\"));\n\nvar _removeEventListeners = _interopRequireDefault(require(\"./utils/remove-event-listeners\"));\n\nvar _each = _interopRequireDefault(require(\"./utils/each\"));\n\nvar _merge = _interopRequireDefault(require(\"./utils/merge\"));\n\nvar _extend = _interopRequireDefault(require(\"./utils/extend\"));\n\nvar _inherit = _interopRequireDefault(require(\"./utils/inherit\"));\n\nvar _bindFn = _interopRequireDefault(require(\"./utils/bind-fn\"));\n\nvar _toArray = _interopRequireDefault(require(\"./utils/to-array\"));\n\nvar _uniqueArray = _interopRequireDefault(require(\"./utils/unique-array\"));\n\nvar _splitStr = _interopRequireDefault(require(\"./utils/split-str\"));\n\nvar _inArray = _interopRequireDefault(require(\"./utils/in-array\"));\n\nvar _boolOrFn = _interopRequireDefault(require(\"./utils/bool-or-fn\"));\n\nvar _hasParent = _interopRequireDefault(require(\"./utils/has-parent\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar _default = (0, _assign.default)(_hammer.default, {\n  INPUT_START: _inputConsts.INPUT_START,\n  INPUT_MOVE: _inputConsts.INPUT_MOVE,\n  INPUT_END: _inputConsts.INPUT_END,\n  INPUT_CANCEL: _inputConsts.INPUT_CANCEL,\n  STATE_POSSIBLE: _recognizerConsts.STATE_POSSIBLE,\n  STATE_BEGAN: _recognizerConsts.STATE_BEGAN,\n  STATE_CHANGED: _recognizerConsts.STATE_CHANGED,\n  STATE_ENDED: _recognizerConsts.STATE_ENDED,\n  STATE_RECOGNIZED: _recognizerConsts.STATE_RECOGNIZED,\n  STATE_CANCELLED: _recognizerConsts.STATE_CANCELLED,\n  STATE_FAILED: _recognizerConsts.STATE_FAILED,\n  DIRECTION_NONE: _inputConsts.DIRECTION_NONE,\n  DIRECTION_LEFT: _inputConsts.DIRECTION_LEFT,\n  DIRECTION_RIGHT: _inputConsts.DIRECTION_RIGHT,\n  DIRECTION_UP: _inputConsts.DIRECTION_UP,\n  DIRECTION_DOWN: _inputConsts.DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL: _inputConsts.DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL: _inputConsts.DIRECTION_VERTICAL,\n  DIRECTION_ALL: _inputConsts.DIRECTION_ALL,\n  Manager: _manager.default,\n  Input: _inputConstructor.default,\n  TouchAction: _touchactionConstructor.default,\n  TouchInput: _touch.default,\n  PointerEventInput: _pointerevent.default,\n  Recognizer: _recognizerConstructor.default,\n  AttrRecognizer: _attribute.default,\n  Tap: _tap.default,\n  Pan: _pan.default,\n  Swipe: _swipe.default,\n  Pinch: _pinch.default,\n  Rotate: _rotate.default,\n  Press: _press.default,\n  on: _addEventListeners.default,\n  off: _removeEventListeners.default,\n  each: _each.default,\n  merge: _merge.default,\n  extend: _extend.default,\n  assign: _assign.default,\n  inherit: _inherit.default,\n  bindFn: _bindFn.default,\n  toArray: _toArray.default,\n  inArray: _inArray.default,\n  uniqueArray: _uniqueArray.default,\n  splitStr: _splitStr.default,\n  boolOrFn: _boolOrFn.default,\n  hasParent: _hasParent.default,\n  addEventListeners: _addEventListeners.default,\n  removeEventListeners: _removeEventListeners.default\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ifUndefined = _interopRequireDefault(require(\"./utils/if-undefined\"));\n\nvar _touchactionConsts = require(\"./touchactionjs/touchaction-Consts\");\n\nvar _inputConsts = require(\"./inputjs/input-consts\");\n\nvar _rotate = _interopRequireDefault(require(\"./recognizers/rotate\"));\n\nvar _pinch = _interopRequireDefault(require(\"./recognizers/pinch\"));\n\nvar _swipe = _interopRequireDefault(require(\"./recognizers/swipe\"));\n\nvar _pan = _interopRequireDefault(require(\"./recognizers/pan\"));\n\nvar _tap = _interopRequireDefault(require(\"./recognizers/tap\"));\n\nvar _press = _interopRequireDefault(require(\"./recognizers/press\"));\n\nvar _manager = _interopRequireDefault(require(\"./manager\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {Object} [options]\n * @constructor\n */\nclass Hammer {\n  constructor(options) {\n    options = options || {};\n    options.recognizers = (0, _ifUndefined.default)(options.recognizers, Hammer.defaults.preset);\n    return new _manager.default(options);\n  }\n\n}\n/**\n * @private\n * default settings\n * @namespace\n */\n\n\nexports.default = Hammer;\nHammer.defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: _touchactionConsts.TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Default recognizer setup when calling `Hammer()`\n   * When creating a new Manager these will be skipped.\n   * @type {Array}\n   */\n  preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n  [_rotate.default, {\n    enable: false\n  }], [_pinch.default, {\n    enable: false\n  }, ['rotate']], [_swipe.default, {\n    direction: _inputConsts.DIRECTION_HORIZONTAL\n  }], [_pan.default, {\n    direction: _inputConsts.DIRECTION_HORIZONTAL\n  }, ['swipe']], [_tap.default], [_tap.default, {\n    event: 'doubletap',\n    taps: 2\n  }, ['tap']], [_press.default]]\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ifUndefined;\n\n/**\n * @private\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n  return val1 === undefined ? val2 : val1;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TOUCH_ACTION_MAP = exports.TOUCH_ACTION_PAN_Y = exports.TOUCH_ACTION_PAN_X = exports.TOUCH_ACTION_NONE = exports.TOUCH_ACTION_MANIPULATION = exports.TOUCH_ACTION_COMPUTE = exports.TOUCH_ACTION_AUTO = void 0;\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _getTouchactionProps = _interopRequireDefault(require(\"./get-touchaction-props\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// magical touchAction value\nconst TOUCH_ACTION_COMPUTE = 'compute';\nexports.TOUCH_ACTION_COMPUTE = TOUCH_ACTION_COMPUTE;\nconst TOUCH_ACTION_AUTO = 'auto';\nexports.TOUCH_ACTION_AUTO = TOUCH_ACTION_AUTO;\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nexports.TOUCH_ACTION_MANIPULATION = TOUCH_ACTION_MANIPULATION;\nconst TOUCH_ACTION_NONE = 'none';\nexports.TOUCH_ACTION_NONE = TOUCH_ACTION_NONE;\nconst TOUCH_ACTION_PAN_X = 'pan-x';\nexports.TOUCH_ACTION_PAN_X = TOUCH_ACTION_PAN_X;\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\nexports.TOUCH_ACTION_PAN_Y = TOUCH_ACTION_PAN_Y;\nconst TOUCH_ACTION_MAP = (0, _getTouchactionProps.default)();\nexports.TOUCH_ACTION_MAP = TOUCH_ACTION_MAP;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.now = exports.abs = exports.round = exports.TYPE_FUNCTION = void 0;\nconst TYPE_FUNCTION = 'function';\nexports.TYPE_FUNCTION = TYPE_FUNCTION;\nconst {\n  round,\n  abs\n} = Math;\nexports.abs = abs;\nexports.round = round;\nconst {\n  now\n} = Date;\nexports.now = now;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getTouchActionProps;\n\nfunction getTouchActionProps() {\n  let touchMap = {};\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(val => {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = true;\n  });\n  return touchMap;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROPS_CLIENT_XY = exports.PROPS_XY = exports.DIRECTION_ALL = exports.DIRECTION_VERTICAL = exports.DIRECTION_HORIZONTAL = exports.DIRECTION_DOWN = exports.DIRECTION_UP = exports.DIRECTION_RIGHT = exports.DIRECTION_LEFT = exports.DIRECTION_NONE = exports.INPUT_CANCEL = exports.INPUT_END = exports.INPUT_MOVE = exports.INPUT_START = exports.COMPUTE_INTERVAL = exports.INPUT_TYPE_TOUCH = exports.INPUT_TYPE_PEN = exports.INPUT_TYPE_MOUSE = exports.INPUT_TYPE_KINECT = void 0;\nconst INPUT_TYPE_TOUCH = 'touch';\nexports.INPUT_TYPE_TOUCH = INPUT_TYPE_TOUCH;\nconst INPUT_TYPE_PEN = 'pen';\nexports.INPUT_TYPE_PEN = INPUT_TYPE_PEN;\nconst INPUT_TYPE_MOUSE = 'mouse';\nexports.INPUT_TYPE_MOUSE = INPUT_TYPE_MOUSE;\nconst INPUT_TYPE_KINECT = 'kinect';\nexports.INPUT_TYPE_KINECT = INPUT_TYPE_KINECT;\nconst COMPUTE_INTERVAL = 25;\nexports.COMPUTE_INTERVAL = COMPUTE_INTERVAL;\nconst INPUT_START = 1;\nexports.INPUT_START = INPUT_START;\nconst INPUT_MOVE = 2;\nexports.INPUT_MOVE = INPUT_MOVE;\nconst INPUT_END = 4;\nexports.INPUT_END = INPUT_END;\nconst INPUT_CANCEL = 8;\nexports.INPUT_CANCEL = INPUT_CANCEL;\nconst DIRECTION_NONE = 1;\nexports.DIRECTION_NONE = DIRECTION_NONE;\nconst DIRECTION_LEFT = 2;\nexports.DIRECTION_LEFT = DIRECTION_LEFT;\nconst DIRECTION_RIGHT = 4;\nexports.DIRECTION_RIGHT = DIRECTION_RIGHT;\nconst DIRECTION_UP = 8;\nexports.DIRECTION_UP = DIRECTION_UP;\nconst DIRECTION_DOWN = 16;\nexports.DIRECTION_DOWN = DIRECTION_DOWN;\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nexports.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nexports.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nexports.DIRECTION_ALL = DIRECTION_ALL;\nconst PROPS_XY = ['x', 'y'];\nexports.PROPS_XY = PROPS_XY;\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\nexports.PROPS_CLIENT_XY = PROPS_CLIENT_XY;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _attribute = _interopRequireDefault(require(\"./attribute\"));\n\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\n\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nclass RotateRecognizer extends _attribute.default {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return [_touchactionConsts.TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) && (Math.abs(input.rotation) > this.options.threshold || this.state & _recognizerConsts.STATE_BEGAN);\n  }\n\n}\n\nexports.default = RotateRecognizer;\nRotateRecognizer.prototype.defaults = {\n  event: 'rotate',\n  threshold: 0,\n  pointers: 2\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _recognizerConstructor = _interopRequireDefault(require(\"../recognizerjs/recognizer-constructor\"));\n\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nclass AttrRecognizer extends _recognizerConstructor.default {\n  constructor() {\n    super(...arguments);\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  attrTest(input) {\n    let optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  process(input) {\n    let {\n      state\n    } = this;\n    let {\n      eventType\n    } = input;\n    let isRecognized = state & (_recognizerConsts.STATE_BEGAN | _recognizerConsts.STATE_CHANGED);\n    let isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & _inputConsts.INPUT_CANCEL || !isValid)) {\n      return state | _recognizerConsts.STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & _inputConsts.INPUT_END) {\n        return state | _recognizerConsts.STATE_ENDED;\n      } else if (!(state & _recognizerConsts.STATE_BEGAN)) {\n        return _recognizerConsts.STATE_BEGAN;\n      }\n\n      return state | _recognizerConsts.STATE_CHANGED;\n    }\n\n    return _recognizerConsts.STATE_FAILED;\n  }\n\n}\n\nexports.default = AttrRecognizer;\nAttrRecognizer.prototype.defaults = {\n  /**\n   * @private\n   * @type {Number}\n   * @default 1\n   */\n  pointers: 1\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _recognizerConsts = require(\"./recognizer-consts\");\n\nvar _assign = _interopRequireDefault(require(\"../utils/assign\"));\n\nvar _uniqueId = _interopRequireDefault(require(\"../utils/unique-id\"));\n\nvar _ifUndefined = _interopRequireDefault(require(\"../utils/if-undefined\"));\n\nvar _invokeArrayArg = _interopRequireDefault(require(\"../utils/invoke-array-arg\"));\n\nvar _inArray = _interopRequireDefault(require(\"../utils/in-array\"));\n\nvar _boolOrFn = _interopRequireDefault(require(\"../utils/bool-or-fn\"));\n\nvar _getRecognizerByNameIfManager = _interopRequireDefault(require(\"./get-recognizer-by-name-if-manager\"));\n\nvar _stateStr = _interopRequireDefault(require(\"./state-str\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nclass Recognizer {\n  constructor(options) {\n    this.options = (0, _assign.default)({}, this.defaults, options || {});\n    this.id = (0, _uniqueId.default)();\n    this.manager = null; // default is enable true\n\n    this.options.enable = (0, _ifUndefined.default)(this.options.enable, true);\n    this.state = _recognizerConsts.STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  set(options) {\n    (0, _assign.default)(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  }\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  recognizeWith(otherRecognizer) {\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    let {\n      simultaneous\n    } = this;\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  dropRecognizeWith(otherRecognizer) {\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  }\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  requireFailure(otherRecognizer) {\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    let {\n      requireFail\n    } = this;\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\n\n    if ((0, _inArray.default)(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  dropRequireFailure(otherRecognizer) {\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\n    let index = (0, _inArray.default)(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  hasRequireFailures() {\n    return this.requireFail.length > 0;\n  }\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  }\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  emit(input) {\n    let self = this;\n    let {\n      state\n    } = this;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < _recognizerConsts.STATE_ENDED) {\n      emit(self.options.event + (0, _stateStr.default)(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= _recognizerConsts.STATE_ENDED) {\n      emit(self.options.event + (0, _stateStr.default)(state));\n    }\n  }\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = _recognizerConsts.STATE_FAILED;\n  }\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  canEmit() {\n    let i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (_recognizerConsts.STATE_FAILED | _recognizerConsts.STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  }\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    let inputDataClone = (0, _assign.default)({}, inputData); // is is enabled and allow recognizing?\n\n    if (!(0, _boolOrFn.default)(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = _recognizerConsts.STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (_recognizerConsts.STATE_RECOGNIZED | _recognizerConsts.STATE_CANCELLED | _recognizerConsts.STATE_FAILED)) {\n      this.state = _recognizerConsts.STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (_recognizerConsts.STATE_BEGAN | _recognizerConsts.STATE_CHANGED | _recognizerConsts.STATE_ENDED | _recognizerConsts.STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  process(inputData) {}\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  getTouchAction() {}\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  reset() {}\n\n}\n\nexports.default = Recognizer;\nRecognizer.prototype.defaults = {};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STATE_FAILED = exports.STATE_CANCELLED = exports.STATE_RECOGNIZED = exports.STATE_ENDED = exports.STATE_CHANGED = exports.STATE_BEGAN = exports.STATE_POSSIBLE = void 0;\nconst STATE_POSSIBLE = 1;\nexports.STATE_POSSIBLE = STATE_POSSIBLE;\nconst STATE_BEGAN = 2;\nexports.STATE_BEGAN = STATE_BEGAN;\nconst STATE_CHANGED = 4;\nexports.STATE_CHANGED = STATE_CHANGED;\nconst STATE_ENDED = 8;\nexports.STATE_ENDED = STATE_ENDED;\nconst STATE_RECOGNIZED = STATE_ENDED;\nexports.STATE_RECOGNIZED = STATE_RECOGNIZED;\nconst STATE_CANCELLED = 16;\nexports.STATE_CANCELLED = STATE_CANCELLED;\nconst STATE_FAILED = 32;\nexports.STATE_FAILED = STATE_FAILED;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nlet assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let output = Object(target);\n\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar _default = assign;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = uniqueId;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nlet _uniqueId = 1;\n\nfunction uniqueId() {\n  return _uniqueId++;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = invokeArrayArg;\n\nvar _each = _interopRequireDefault(require(\"./each\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    (0, _each.default)(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = each;\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  let i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inArray;\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    let i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = boolOrFn;\n\nvar _utilsConsts = require(\"./utils-consts\");\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n  if (typeof val === _utilsConsts.TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getRecognizerByNameIfManager;\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  let {\n    manager\n  } = recognizer;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = stateStr;\n\nvar _recognizerConsts = require(\"./recognizer-consts\");\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n  if (state & _recognizerConsts.STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & _recognizerConsts.STATE_ENDED) {\n    return 'end';\n  } else if (state & _recognizerConsts.STATE_CHANGED) {\n    return 'move';\n  } else if (state & _recognizerConsts.STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _attribute = _interopRequireDefault(require(\"./attribute\"));\n\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\n\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nclass PinchRecognizer extends _attribute.default {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return [_touchactionConsts.TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & _recognizerConsts.STATE_BEGAN);\n  }\n\n  emit(input) {\n    if (input.scale !== 1) {\n      let inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    super.emit(input);\n  }\n\n}\n\nexports.default = PinchRecognizer;\nPinchRecognizer.prototype.defaults = {\n  event: 'pinch',\n  threshold: 0,\n  pointers: 2\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _attribute = _interopRequireDefault(require(\"../recognizers/attribute\"));\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nvar _pan = _interopRequireDefault(require(\"./pan\"));\n\nvar _directionStr = _interopRequireDefault(require(\"../recognizerjs/direction-str\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nclass SwipeRecognizer extends _attribute.default {\n  constructor() {\n    super(...arguments);\n  }\n\n  getTouchAction() {\n    return _pan.default.prototype.getTouchAction.call(this);\n  }\n\n  attrTest(input) {\n    let {\n      direction\n    } = this.options;\n    let velocity;\n\n    if (direction & (_inputConsts.DIRECTION_HORIZONTAL | _inputConsts.DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & _inputConsts.DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & _inputConsts.DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return super.attrTest(input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && (0, _utilsConsts.abs)(velocity) > this.options.velocity && input.eventType & _inputConsts.INPUT_END;\n  }\n\n  emit(input) {\n    let direction = (0, _directionStr.default)(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n\n}\n\nexports.default = SwipeRecognizer;\nSwipeRecognizer.prototype.defaults = {\n  event: 'swipe',\n  threshold: 10,\n  velocity: 0.3,\n  direction: _inputConsts.DIRECTION_HORIZONTAL | _inputConsts.DIRECTION_VERTICAL,\n  pointers: 1\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _attribute = _interopRequireDefault(require(\"./attribute\"));\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\n\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\n\nvar _directionStr = _interopRequireDefault(require(\"../recognizerjs/direction-str\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nclass PanRecognizer extends _attribute.default {\n  constructor() {\n    super(...arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction() {\n    let {\n      options: {\n        direction\n      }\n    } = this;\n    let actions = [];\n\n    if (direction & _inputConsts.DIRECTION_HORIZONTAL) {\n      actions.push(_touchactionConsts.TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & _inputConsts.DIRECTION_VERTICAL) {\n      actions.push(_touchactionConsts.TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  }\n\n  directionTest(input) {\n    let {\n      options\n    } = this;\n    let hasMoved = true;\n    let {\n      distance\n    } = input;\n    let {\n      direction\n    } = input;\n    let x = input.deltaX;\n    let y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & _inputConsts.DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? _inputConsts.DIRECTION_NONE : x < 0 ? _inputConsts.DIRECTION_LEFT : _inputConsts.DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? _inputConsts.DIRECTION_NONE : y < 0 ? _inputConsts.DIRECTION_UP : _inputConsts.DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  }\n\n  attrTest(input) {\n    return _attribute.default.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & _recognizerConsts.STATE_BEGAN || !(this.state & _recognizerConsts.STATE_BEGAN) && this.directionTest(input));\n  }\n\n  emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    let direction = (0, _directionStr.default)(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    super.emit(input);\n  }\n\n}\n\nexports.default = PanRecognizer;\nPanRecognizer.prototype.defaults = {\n  event: 'pan',\n  threshold: 10,\n  pointers: 1,\n  direction: _inputConsts.DIRECTION_ALL\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = directionStr;\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n  if (direction === _inputConsts.DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === _inputConsts.DIRECTION_UP) {\n    return 'up';\n  } else if (direction === _inputConsts.DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === _inputConsts.DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _setTimeoutContext = _interopRequireDefault(require(\"../utils/set-timeout-context\"));\n\nvar _recognizerConstructor = _interopRequireDefault(require(\"../recognizerjs/recognizer-constructor\"));\n\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\n\nvar _getDistance = _interopRequireDefault(require(\"../inputjs/get-distance\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nclass TapRecognizer extends _recognizerConstructor.default {\n  constructor() {\n    super(...arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  getTouchAction() {\n    return [_touchactionConsts.TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input) {\n    let {\n      options\n    } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & _inputConsts.INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== _inputConsts.INPUT_END) {\n        return this.failTimeout();\n      }\n\n      let validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      let validMultiTap = !this.pCenter || (0, _getDistance.default)(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      let tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return _recognizerConsts.STATE_RECOGNIZED;\n        } else {\n          this._timer = (0, _setTimeoutContext.default)(() => {\n            this.state = _recognizerConsts.STATE_RECOGNIZED;\n            this.tryEmit();\n          }, options.interval, this);\n          return _recognizerConsts.STATE_BEGAN;\n        }\n      }\n    }\n\n    return _recognizerConsts.STATE_FAILED;\n  }\n\n  failTimeout() {\n    this._timer = (0, _setTimeoutContext.default)(() => {\n      this.state = _recognizerConsts.STATE_FAILED;\n    }, this.options.interval, this);\n    return _recognizerConsts.STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit() {\n    if (this.state === _recognizerConsts.STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n\n}\n\nexports.default = TapRecognizer;\nTapRecognizer.prototype.defaults = {\n  event: 'tap',\n  pointers: 1,\n  taps: 1,\n  interval: 300,\n  // max time between the multi-tap taps\n  time: 250,\n  // max time of the pointer to be down (like finger on the screen)\n  threshold: 9,\n  // a minimal movement is ok, but keep it low\n  posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = setTimeoutContext;\n\nvar _bindFn = _interopRequireDefault(require(\"./bind-fn\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n  return setTimeout((0, _bindFn.default)(fn, context), timeout);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = bindFn;\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getDistance;\n\nvar _inputConsts = require(\"./input-consts\");\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = _inputConsts.PROPS_XY;\n  }\n\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _recognizerConstructor = _interopRequireDefault(require(\"../recognizerjs/recognizer-constructor\"));\n\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _setTimeoutContext = _interopRequireDefault(require(\"../utils/set-timeout-context\"));\n\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nclass PressRecognizer extends _recognizerConstructor.default {\n  constructor() {\n    super(...arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  getTouchAction() {\n    return [_touchactionConsts.TOUCH_ACTION_AUTO];\n  }\n\n  process(input) {\n    let {\n      options\n    } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & _inputConsts.INPUT_START) {\n      this.reset();\n      this._timer = (0, _setTimeoutContext.default)(() => {\n        this.state = _recognizerConsts.STATE_RECOGNIZED;\n        this.tryEmit();\n      }, options.time, this);\n    } else if (input.eventType & _inputConsts.INPUT_END) {\n      return _recognizerConsts.STATE_RECOGNIZED;\n    }\n\n    return _recognizerConsts.STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input) {\n    if (this.state !== _recognizerConsts.STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & _inputConsts.INPUT_END) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = (0, _utilsConsts.now)();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n\n}\n\nexports.default = PressRecognizer;\nPressRecognizer.prototype.defaults = {\n  event: 'press',\n  pointers: 1,\n  time: 251,\n  // minimal time of the pointer to be pressed\n  threshold: 9 // a minimal movement is ok, but keep it low\n\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _assign = _interopRequireDefault(require(\"./utils/assign\"));\n\nvar _hammer = _interopRequireDefault(require(\"./hammer\"));\n\nvar _touchactionConstructor = _interopRequireDefault(require(\"./touchactionjs/touchaction-constructor\"));\n\nvar _createInputInstance = _interopRequireDefault(require(\"./inputjs/create-input-instance\"));\n\nvar _each = _interopRequireDefault(require(\"./utils/each\"));\n\nvar _inArray = _interopRequireDefault(require(\"./utils/in-array\"));\n\nvar _invokeArrayArg = _interopRequireDefault(require(\"./utils/invoke-array-arg\"));\n\nvar _splitStr = _interopRequireDefault(require(\"./utils/split-str\"));\n\nvar _recognizerConstructor = _interopRequireDefault(require(\"./recognizerjs/recognizer-constructor\"));\n\nvar _recognizerConsts = require(\"./recognizerjs/recognizer-consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n/**\n * @private\n * Manager\n * @param {Object} [options]\n * @constructor\n */\n\nclass Manager {\n  constructor(options) {\n    this.options = (0, _assign.default)({}, _hammer.default.defaults, options || {});\n    this.handlers = {};\n    this.filters = [];\n    this.session = {};\n    this.recognizers = [];\n    this.input = (0, _createInputInstance.default)(this);\n    this.touchAction = new _touchactionConstructor.default(this, this.options.touchAction);\n    (0, _each.default)(this.options.recognizers, item => {\n      let recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  set(options) {\n    (0, _assign.default)(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n  /**\n   * @private\n   * add event filters\n   */\n\n\n  addFilter(filter) {\n    if (typeof filter !== 'function') {\n      throw new Error('filter must be a function');\n    }\n\n    this.filters.push(filter);\n  }\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  recognize(inputData) {\n    let {\n      session\n    } = this;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    let recognizer;\n    let {\n      recognizers\n    } = this; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    let {\n      curRecognizer\n    } = session; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & _recognizerConsts.STATE_RECOGNIZED) {\n      curRecognizer = session.curRecognizer = null;\n    }\n\n    let i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (_recognizerConsts.STATE_BEGAN | _recognizerConsts.STATE_CHANGED | _recognizerConsts.STATE_ENDED)) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  }\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  get(recognizer) {\n    if (recognizer instanceof _recognizerConstructor.default) {\n      return recognizer;\n    }\n\n    let {\n      recognizers\n    } = this;\n\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  add(recognizer) {\n    if ((0, _invokeArrayArg.default)(recognizer, 'add', this)) {\n      return this;\n    } // remove existing\n\n\n    let existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  }\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  remove(recognizer) {\n    if ((0, _invokeArrayArg.default)(recognizer, 'remove', this)) {\n      return this;\n    }\n\n    recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      let {\n        recognizers\n      } = this;\n      let index = (0, _inArray.default)(recognizers, recognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  on(events, handler) {\n    if (events === undefined) {\n      return;\n    }\n\n    if (handler === undefined) {\n      return;\n    }\n\n    let {\n      handlers\n    } = this;\n    (0, _each.default)((0, _splitStr.default)(events), event => {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  }\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  off(events, handler) {\n    if (events === undefined) {\n      return;\n    }\n\n    let {\n      handlers\n    } = this;\n    (0, _each.default)((0, _splitStr.default)(events), event => {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice((0, _inArray.default)(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  }\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  emit(event, data) {\n    // no handlers, so skip it all\n    let handlers = this.handlers[event] && this.handlers[event].slice();\n    const {\n      filters\n    } = this;\n\n    if (!handlers || !handlers.length) {\n      return;\n    } //let i = 0;\n    //let newData = Object.assign(data);\n    //data.type = event;\n    //data.preventDefault = function() {\n    //  data.srcEvent.preventDefault();\n    //};\n    //while (i < filters.length) {\n    //  newData = filters[i](newData);\n    //  i++;\n    //}\n    //\n\n\n    if (!event.startsWith('origin_input')) {\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n    }\n\n    let i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  }\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  destroy() {\n    this.handlers = {};\n    this.filters = [];\n    this.session = {};\n    this.input.destroy();\n  }\n\n}\n\nexports.default = Manager;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _touchactionConsts = require(\"./touchaction-Consts\");\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nvar _each = _interopRequireDefault(require(\"../utils/each\"));\n\nvar _boolOrFn = _interopRequireDefault(require(\"../utils/bool-or-fn\"));\n\nvar _inStr = _interopRequireDefault(require(\"../utils/in-str\"));\n\nvar _cleanTouchActions = _interopRequireDefault(require(\"./clean-touch-actions\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nclass TouchAction {\n  constructor(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  set(value) {\n    // find out the touch-action by the event handlers\n    if (value === _touchactionConsts.TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    this.actions = value.toLowerCase().trim();\n  }\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  compute() {\n    let actions = [];\n    (0, _each.default)(this.manager.recognizers, recognizer => {\n      if ((0, _boolOrFn.default)(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return (0, _cleanTouchActions.default)(actions.join(' '));\n  }\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  preventDefaults(input) {\n    let {\n      srcEvent\n    } = input;\n    let direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    let {\n      actions\n    } = this;\n    let hasNone = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_NONE) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_NONE];\n    let hasPanY = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_Y) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_PAN_Y];\n    let hasPanX = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_X) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      let isTapPointer = input.pointers.length === 1;\n      let isTapMovement = input.distance < 2;\n      let isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & _inputConsts.DIRECTION_HORIZONTAL || hasPanX && direction & _inputConsts.DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  }\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  }\n\n}\n\nexports.default = TouchAction;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inStr;\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cleanTouchActions;\n\nvar _inStr = _interopRequireDefault(require(\"../utils/in-str\"));\n\nvar _touchactionConsts = require(\"./touchaction-Consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n  // none\n  if ((0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_NONE)) {\n    return _touchactionConsts.TOUCH_ACTION_NONE;\n  }\n\n  let hasPanX = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_X);\n  let hasPanY = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return _touchactionConsts.TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? _touchactionConsts.TOUCH_ACTION_PAN_X : _touchactionConsts.TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if ((0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_MANIPULATION)) {\n    return _touchactionConsts.TOUCH_ACTION_MANIPULATION;\n  }\n\n  return _touchactionConsts.TOUCH_ACTION_AUTO;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createInputInstance;\n\nvar _inputHandler = _interopRequireDefault(require(\"./input-handler\"));\n\nvar _touch = _interopRequireDefault(require(\"../input/touch\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n  let Type = _touch.default;\n\n  if (manager.options.inputClass) {\n    Type = inputClass;\n  }\n\n  return new Type(manager, _inputHandler.default);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inputHandler;\n\nvar _inputConsts = require(\"./input-consts\");\n\nvar _computeInputData = _interopRequireDefault(require(\"./compute-input-data\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n  let pointersLen = input.pointers.length;\n  let changedPointersLen = input.changedPointers.length;\n  let isFirst = eventType & _inputConsts.INPUT_START && pointersLen - changedPointersLen === 0;\n  let isFinal = eventType & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  (0, _computeInputData.default)(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = computeInputData;\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _hasParent = _interopRequireDefault(require(\"../utils/has-parent\"));\n\nvar _simpleCloneInputData = _interopRequireDefault(require(\"./simple-clone-input-data\"));\n\nvar _getCenter = _interopRequireDefault(require(\"./get-center\"));\n\nvar _getDistance = _interopRequireDefault(require(\"./get-distance\"));\n\nvar _getAngle = _interopRequireDefault(require(\"./get-angle\"));\n\nvar _getDirection = _interopRequireDefault(require(\"./get-direction\"));\n\nvar _computeDeltaXy = _interopRequireDefault(require(\"./compute-delta-xy\"));\n\nvar _getVelocity = _interopRequireDefault(require(\"./get-velocity\"));\n\nvar _getScale = _interopRequireDefault(require(\"./get-scale\"));\n\nvar _getRotation = _interopRequireDefault(require(\"./get-rotation\"));\n\nvar _computeIntervalInputData = _interopRequireDefault(require(\"./compute-interval-input-data\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n  let {\n    session\n  } = manager;\n  let {\n    pointers\n  } = input;\n  let {\n    length: pointersLength\n  } = pointers; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = (0, _simpleCloneInputData.default)(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = (0, _simpleCloneInputData.default)(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  let {\n    firstInput,\n    firstMultiple\n  } = session;\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  let center = input.center = (0, _getCenter.default)(pointers);\n  input.timeStamp = (0, _utilsConsts.now)();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = (0, _getAngle.default)(offsetCenter, center);\n  input.distance = (0, _getDistance.default)(offsetCenter, center);\n  (0, _computeDeltaXy.default)(session, input);\n  input.offsetDirection = (0, _getDirection.default)(input.deltaX, input.deltaY);\n  let overallVelocity = (0, _getVelocity.default)(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = (0, _utilsConsts.abs)(overallVelocity.x) > (0, _utilsConsts.abs)(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? (0, _getScale.default)(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? (0, _getRotation.default)(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  (0, _computeIntervalInputData.default)(session, input);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = hasParent;\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simpleCloneInputData;\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _getCenter = _interopRequireDefault(require(\"./get-center\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  let pointers = [];\n  let i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: (0, _utilsConsts.round)(input.pointers[i].clientX),\n      clientY: (0, _utilsConsts.round)(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: (0, _utilsConsts.now)(),\n    pointers,\n    center: (0, _getCenter.default)(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getCenter;\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n  let pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: (0, _utilsConsts.round)(pointers[0].clientX),\n      y: (0, _utilsConsts.round)(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: (0, _utilsConsts.round)(x / pointersLength),\n    y: (0, _utilsConsts.round)(y / pointersLength)\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getAngle;\n\nvar _inputConsts = require(\"./input-consts\");\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = _inputConsts.PROPS_XY;\n  }\n\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getDirection;\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _inputConsts = require(\"./input-consts\");\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n  if (x === y) {\n    return _inputConsts.DIRECTION_NONE;\n  }\n\n  if ((0, _utilsConsts.abs)(x) >= (0, _utilsConsts.abs)(y)) {\n    return x < 0 ? _inputConsts.DIRECTION_LEFT : _inputConsts.DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? _inputConsts.DIRECTION_UP : _inputConsts.DIRECTION_DOWN;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = computeDeltaXY;\n\nvar _inputConsts = require(\"./input-consts\");\n\nfunction computeDeltaXY(session, input) {\n  let {\n    center\n  } = input; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  let offset = session.offsetDelta || {};\n  let prevDelta = session.prevDelta || {};\n  let prevInput = session.prevInput || {};\n\n  if (input.eventType === _inputConsts.INPUT_START || prevInput.eventType === _inputConsts.INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getVelocity;\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getScale;\n\nvar _inputConsts = require(\"./input-consts\");\n\nvar _getDistance = _interopRequireDefault(require(\"./get-distance\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n  return (0, _getDistance.default)(end[0], end[1], _inputConsts.PROPS_CLIENT_XY) / (0, _getDistance.default)(start[0], start[1], _inputConsts.PROPS_CLIENT_XY);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getRotation;\n\nvar _getAngle = _interopRequireDefault(require(\"./get-angle\"));\n\nvar _inputConsts = require(\"./input-consts\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n  return (0, _getAngle.default)(end[1], end[0], _inputConsts.PROPS_CLIENT_XY) + (0, _getAngle.default)(start[1], start[0], _inputConsts.PROPS_CLIENT_XY);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = computeIntervalInputData;\n\nvar _inputConsts = require(\"./input-consts\");\n\nvar _utilsConsts = require(\"../utils/utils-consts\");\n\nvar _getVelocity = _interopRequireDefault(require(\"./get-velocity\"));\n\nvar _getDirection = _interopRequireDefault(require(\"./get-direction\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (input.eventType !== _inputConsts.INPUT_CANCEL && (deltaTime > _inputConsts.COMPUTE_INTERVAL || last.velocity === undefined)) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n    let v = (0, _getVelocity.default)(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = (0, _utilsConsts.abs)(v.x) > (0, _utilsConsts.abs)(v.y) ? v.x : v.y;\n    direction = (0, _getDirection.default)(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nvar _inputConstructor = _interopRequireDefault(require(\"../inputjs/input-constructor\"));\n\nvar _toArray = _interopRequireDefault(require(\"../utils/to-array\"));\n\nvar _hasParent = _interopRequireDefault(require(\"../utils/has-parent\"));\n\nvar _uniqueArray = _interopRequireDefault(require(\"../utils/unique-array\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TOUCH_INPUT_MAP = {\n  touchstart: _inputConsts.INPUT_START,\n  touchmove: _inputConsts.INPUT_MOVE,\n  touchend: _inputConsts.INPUT_END,\n  touchcancel: _inputConsts.INPUT_CANCEL\n};\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nclass TouchInput extends _inputConstructor.default {\n  constructor() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    TouchInput.prototype.targetIds = {};\n    TouchInput.prototype.events = TOUCH_TARGET_EVENTS;\n    super(...arguments);\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n  }\n\n  handler(ev) {\n    let type = TOUCH_INPUT_MAP[ev.type];\n    let touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: _inputConsts.INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n\n}\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\n\n\nexports.default = TouchInput;\n\nfunction getTouches(ev, type) {\n  let allTouches = (0, _toArray.default)(ev.touches);\n  let {\n    targetIds\n  } = this; // when there is only one touch, the process can be simplified\n\n  if (type & (_inputConsts.INPUT_START | _inputConsts.INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  let i;\n  let targetTouches;\n  let changedTouches = (0, _toArray.default)(ev.changedTouches);\n  let changedTargetTouches = [];\n  let {\n    target\n  } = this; //// get target touches from touches targets\n  //targetTouches = allTouches.filter((touch) => {\n  //  return hasParent(touch.target, target);\n  //});\n\n  targetTouches = allTouches; // collect touches\n\n  if (type === _inputConsts.INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  (0, _uniqueArray.default)(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _boolOrFn = _interopRequireDefault(require(\"../utils/bool-or-fn\"));\n\nvar _addEventListeners = require(\"../utils/add-event-listeners\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nclass Input {\n  constructor(manager, callback) {\n    let self = this;\n    this.manager = manager;\n    this.callback = callback; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.eventHandler = function (ev) {\n      if ((0, _boolOrFn.default)(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  handler() {}\n  /**\n   * @private\n   */\n\n\n  init() {\n    (0, _addEventListeners.addManagerListeners)(this.manager, this.events || '', this.eventHandler);\n  }\n  /**\n   * @private\n   */\n\n\n  destroy() {\n    removeManagerListeners(this.manager, this.events || '', this.eventHandler);\n  }\n\n}\n\nexports.default = Input;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addEventListeners;\nexports.addManagerListeners = addManagerListeners;\n\nvar _each = _interopRequireDefault(require(\"./each\"));\n\nvar _splitStr = _interopRequireDefault(require(\"./split-str\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n  (0, _each.default)((0, _splitStr.default)(types), type => {\n    target.addEventListener(type, handler, false);\n  });\n}\n\nfunction addManagerListeners(manager, types, handler) {\n  (0, _each.default)((0, _splitStr.default)(types), type => {\n    manager.on(`origin_input:${type}`, handler);\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitStr;\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toArray;\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = uniqueArray;\n\nvar _inArray = _interopRequireDefault(require(\"./in-array\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n  let results = [];\n  let values = [];\n  let i = 0;\n\n  while (i < src.length) {\n    let val = key ? src[i][key] : src[i];\n\n    if ((0, _inArray.default)(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort((a, b) => {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inputConsts = require(\"../inputjs/input-consts\");\n\nvar _inputConstructor = _interopRequireDefault(require(\"../inputjs/input-constructor\"));\n\nvar _inArray = _interopRequireDefault(require(\"../utils/in-array\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: _inputConsts.INPUT_START,\n  pointermove: _inputConsts.INPUT_MOVE,\n  pointerup: _inputConsts.INPUT_END,\n  pointercancel: _inputConsts.INPUT_CANCEL,\n  pointerout: _inputConsts.INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nconst IE10_POINTER_TYPE_ENUM = {\n  2: _inputConsts.INPUT_TYPE_TOUCH,\n  3: _inputConsts.INPUT_TYPE_PEN,\n  4: _inputConsts.INPUT_TYPE_MOUSE,\n  5: _inputConsts.INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\nclass PointerEventInput extends _inputConstructor.default {\n  constructor() {\n    PointerEventInput.prototype.events = `${POINTER_ELEMENT_EVENTS} ${POINTER_WINDOW_EVENTS}`;\n    super(...arguments);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    this.store = this.manager.session.pointerEvents = [];\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  handler(ev) {\n    let {\n      store\n    } = this;\n    let removePointer = false;\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    let isTouch = pointerType === _inputConsts.INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    let storeIndex = (0, _inArray.default)(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & _inputConsts.INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n\n}\n\nexports.default = PointerEventInput;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeEventListeners;\nexports.removeManagerListeners = removeManagerListeners;\n\nvar _each = _interopRequireDefault(require(\"./each\"));\n\nvar _splitStr = _interopRequireDefault(require(\"./split-str\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n  (0, _each.default)((0, _splitStr.default)(types), type => {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\nfunction removeManagerListeners(manager, types, handler) {\n  (0, _each.default)((0, _splitStr.default)(types), type => {\n    manager.off(`origin_input:${type}`, handler);\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _deprecate = _interopRequireDefault(require(\"./deprecate\"));\n\nvar _extend = _interopRequireDefault(require(\"./extend\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nconst merge = (0, _deprecate.default)((dest, src) => {\n  return (0, _extend.default)(dest, src, true);\n}, 'merge', 'Use `assign`.');\nvar _default = merge;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = deprecate;\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\n  return function () {\n    let e = new Error('get-stack-trace');\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    let log = console.warn;\n\n    if (log) {\n      log(deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _deprecate = _interopRequireDefault(require(\"./deprecate\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nconst extend = (0, _deprecate.default)((dest, src, merge) => {\n  let keys = Object.keys(src);\n  let i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\nvar _default = extend;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherit;\n\nvar _assign = _interopRequireDefault(require(\"./assign\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n  let baseP = base.prototype;\n  let childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    (0, _assign.default)(childP, properties);\n  }\n}"]}